var Ze=Object.defineProperty;var Ke=(i,t,e)=>t in i?Ze(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var C=(i,t,e)=>(Ke(i,typeof t!="symbol"?t+"":t,e),e),be=(i,t,e)=>{if(!t.has(i))throw TypeError("Cannot "+e)};var Qt=(i,t,e)=>(be(i,t,"read from private field"),e?e.call(i):t.get(i)),R=(i,t,e)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,e)};var V=(i,t,e)=>(be(i,t,"access private method"),e);import{O as $e}from"./OrbitControls-9aed3e1e.js";import{V as B,B as Je,e as Jt,K as ut,a0 as Ee,aT as E,aU as bt,aN as Qe,M as K,o as tn,D as en,y as et,aH as we,d as Vt,aV as nn,a1 as ye,T as sn,aW as on,b as le,f as rn,$ as cn,g as Fe,S as an,P as ln,W as fn,a5 as un,a as dn,E as pn}from"./three.module-aff2c202.js";import{d as mn}from"./index-1a26f821.js";import{u as ge}from"./index-78d9cafd.js";import{G as hn}from"./GLTFLoader-90ea63a5.js";import{R as yn}from"./Reflector-a32d586d.js";import{k as xn,d as bn,s as wn,l as gn,p as An,o as Sn,c as Tn}from"./index-78fb54d7.js";const pt=new B;function k(i,t,e,n,s,o){const c=2*Math.PI*s/4,a=Math.max(o-2*s,0),r=Math.PI/4;pt.copy(t),pt[n]=0,pt.normalize();const u=.5*c/(c+a),l=1-pt.angleTo(i)/r;return Math.sign(pt[e])===1?l*u:a/(c+a)+u+u*(1-l)}class Pn extends Je{constructor(t=1,e=1,n=1,s=2,o=.1){if(s=s*2+1,o=Math.min(t/2,e/2,n/2,o),super(1,1,1,s,s,s),s===1)return;const c=this.toNonIndexed();this.index=null,this.attributes.position=c.attributes.position,this.attributes.normal=c.attributes.normal,this.attributes.uv=c.attributes.uv;const a=new B,r=new B,u=new B(t,e,n).divideScalar(2).subScalar(o),l=this.attributes.position.array,d=this.attributes.normal.array,f=this.attributes.uv.array,m=l.length/6,x=new B,S=.5/s;for(let y=0,p=0;y<l.length;y+=3,p+=2)switch(a.fromArray(l,y),r.copy(a),r.x-=Math.sign(r.x)*S,r.y-=Math.sign(r.y)*S,r.z-=Math.sign(r.z)*S,r.normalize(),l[y+0]=u.x*Math.sign(a.x)+r.x*o,l[y+1]=u.y*Math.sign(a.y)+r.y*o,l[y+2]=u.z*Math.sign(a.z)+r.z*o,d[y+0]=r.x,d[y+1]=r.y,d[y+2]=r.z,Math.floor(y/m)){case 0:x.set(1,0,0),f[p+0]=k(x,r,"z","y",o,n),f[p+1]=1-k(x,r,"y","z",o,e);break;case 1:x.set(-1,0,0),f[p+0]=1-k(x,r,"z","y",o,n),f[p+1]=1-k(x,r,"y","z",o,e);break;case 2:x.set(0,1,0),f[p+0]=1-k(x,r,"x","z",o,t),f[p+1]=k(x,r,"z","x",o,n);break;case 3:x.set(0,-1,0),f[p+0]=1-k(x,r,"x","z",o,t),f[p+1]=1-k(x,r,"z","x",o,n);break;case 4:x.set(0,0,1),f[p+0]=1-k(x,r,"x","y",o,t),f[p+1]=1-k(x,r,"y","x",o,e);break;case 5:x.set(0,0,-1),f[p+0]=k(x,r,"x","y",o,t),f[p+1]=1-k(x,r,"y","x",o,e);break}}}const Ve=0,vn=1,Bn=2,Ae=2,te=1.25,Se=1,Dt=6*4+4+4,fe=65535,Mn=Math.pow(2,-24);class Mt{constructor(){}}function N(i,t,e){return e.min.x=t[i],e.min.y=t[i+1],e.min.z=t[i+2],e.max.x=t[i+3],e.max.y=t[i+4],e.max.z=t[i+5],e}function _n(i){i[0]=i[1]=i[2]=1/0,i[3]=i[4]=i[5]=-1/0}function Te(i){let t=-1,e=-1/0;for(let n=0;n<3;n++){const s=i[n+3]-i[n];s>e&&(e=s,t=n)}return t}function Pe(i,t){t.set(i)}function ve(i,t,e){let n,s;for(let o=0;o<3;o++){const c=o+3;n=i[o],s=t[o],e[o]=n<s?n:s,n=i[c],s=t[c],e[c]=n>s?n:s}}function _t(i,t,e){for(let n=0;n<3;n++){const s=t[i+2*n],o=t[i+2*n+1],c=s-o,a=s+o;c<e[n]&&(e[n]=c),a>e[n+3]&&(e[n+3]=a)}}function mt(i){const t=i[3]-i[0],e=i[4]-i[1],n=i[5]-i[2];return 2*(t*e+e*n+n*t)}function In(i,t){if(!i.index){const e=i.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let s;e>65535?s=new Uint32Array(new n(4*e)):s=new Uint16Array(new n(2*e)),i.setIndex(new Jt(s,1));for(let o=0;o<e;o++)s[o]=o}}function zn(i){if(!i.groups||!i.groups.length)return[{offset:0,count:i.index.count/3}];const t=[],e=new Set;for(const s of i.groups)e.add(s.start),e.add(s.start+s.count);const n=Array.from(e.values()).sort((s,o)=>s-o);for(let s=0;s<n.length-1;s++){const o=n[s],c=n[s+1];t.push({offset:o/3,count:(c-o)/3})}return t}function ee(i,t,e,n,s=null){let o=1/0,c=1/0,a=1/0,r=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,m=1/0,x=-1/0,S=-1/0,y=-1/0;const p=s!==null;for(let b=t*6,h=(t+e)*6;b<h;b+=6){const g=i[b+0],w=i[b+1],A=g-w,P=g+w;A<o&&(o=A),P>r&&(r=P),p&&g<d&&(d=g),p&&g>x&&(x=g);const v=i[b+2],T=i[b+3],M=v-T,_=v+T;M<c&&(c=M),_>u&&(u=_),p&&v<f&&(f=v),p&&v>S&&(S=v);const I=i[b+4],z=i[b+5],L=I-z,U=I+z;L<a&&(a=L),U>l&&(l=U),p&&I<m&&(m=I),p&&I>y&&(y=I)}n[0]=o,n[1]=c,n[2]=a,n[3]=r,n[4]=u,n[5]=l,p&&(s[0]=d,s[1]=f,s[2]=m,s[3]=x,s[4]=S,s[5]=y)}function Cn(i,t,e,n){let s=1/0,o=1/0,c=1/0,a=-1/0,r=-1/0,u=-1/0;for(let l=t*6,d=(t+e)*6;l<d;l+=6){const f=i[l+0];f<s&&(s=f),f>a&&(a=f);const m=i[l+2];m<o&&(o=m),m>r&&(r=m);const x=i[l+4];x<c&&(c=x),x>u&&(u=x)}n[0]=s,n[1]=o,n[2]=c,n[3]=a,n[4]=r,n[5]=u}function Ln(i,t,e,n,s){let o=e,c=e+n-1;const a=s.pos,r=s.axis*2;for(;;){for(;o<=c&&t[o*6+r]<a;)o++;for(;o<=c&&t[c*6+r]>=a;)c--;if(o<c){for(let u=0;u<3;u++){let l=i[o*3+u];i[o*3+u]=i[c*3+u],i[c*3+u]=l;let d=t[o*6+u*2+0];t[o*6+u*2+0]=t[c*6+u*2+0],t[c*6+u*2+0]=d;let f=t[o*6+u*2+1];t[o*6+u*2+1]=t[c*6+u*2+1],t[c*6+u*2+1]=f}o++,c--}else return o}}const j=32,Un=(i,t)=>i.candidate-t.candidate,X=new Array(j).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),It=new Float32Array(6);function kn(i,t,e,n,s,o){let c=-1,a=0;if(o===Ve)c=Te(t),c!==-1&&(a=(t[c]+t[c+3])/2);else if(o===vn)c=Te(i),c!==-1&&(a=Rn(e,n,s,c));else if(o===Bn){const r=mt(i);let u=te*s;const l=n*6,d=(n+s)*6;for(let f=0;f<3;f++){const m=t[f],y=(t[f+3]-m)/j;if(s<j/4){const p=[...X];p.length=s;let b=0;for(let g=l;g<d;g+=6,b++){const w=p[b];w.candidate=e[g+2*f],w.count=0;const{bounds:A,leftCacheBounds:P,rightCacheBounds:v}=w;for(let T=0;T<3;T++)v[T]=1/0,v[T+3]=-1/0,P[T]=1/0,P[T+3]=-1/0,A[T]=1/0,A[T+3]=-1/0;_t(g,e,A)}p.sort(Un);let h=s;for(let g=0;g<h;g++){const w=p[g];for(;g+1<h&&p[g+1].candidate===w.candidate;)p.splice(g+1,1),h--}for(let g=l;g<d;g+=6){const w=e[g+2*f];for(let A=0;A<h;A++){const P=p[A];w>=P.candidate?_t(g,e,P.rightCacheBounds):(_t(g,e,P.leftCacheBounds),P.count++)}}for(let g=0;g<h;g++){const w=p[g],A=w.count,P=s-w.count,v=w.leftCacheBounds,T=w.rightCacheBounds;let M=0;A!==0&&(M=mt(v)/r);let _=0;P!==0&&(_=mt(T)/r);const I=Se+te*(M*A+_*P);I<u&&(c=f,u=I,a=w.candidate)}}else{for(let h=0;h<j;h++){const g=X[h];g.count=0,g.candidate=m+y+h*y;const w=g.bounds;for(let A=0;A<3;A++)w[A]=1/0,w[A+3]=-1/0}for(let h=l;h<d;h+=6){let A=~~((e[h+2*f]-m)/y);A>=j&&(A=j-1);const P=X[A];P.count++,_t(h,e,P.bounds)}const p=X[j-1];Pe(p.bounds,p.rightCacheBounds);for(let h=j-2;h>=0;h--){const g=X[h],w=X[h+1];ve(g.bounds,w.rightCacheBounds,g.rightCacheBounds)}let b=0;for(let h=0;h<j-1;h++){const g=X[h],w=g.count,A=g.bounds,v=X[h+1].rightCacheBounds;w!==0&&(b===0?Pe(A,It):ve(A,It,It)),b+=w;let T=0,M=0;b!==0&&(T=mt(It)/r);const _=s-b;_!==0&&(M=mt(v)/r);const I=Se+te*(T*b+M*_);I<u&&(c=f,u=I,a=g.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:c,pos:a}}function Rn(i,t,e,n){let s=0;for(let o=t,c=t+e;o<c;o++)s+=i[o*6+n*2];return s/e}function En(i,t){_n(t);const e=i.attributes.position,n=i.index.array,s=n.length/3,o=new Float32Array(s*6),c=e.normalized,a=e.array,r=e.offset||0;let u=3;e.isInterleavedBufferAttribute&&(u=e.data.stride);const l=["getX","getY","getZ"];for(let d=0;d<s;d++){const f=d*3,m=d*6;let x,S,y;c?(x=n[f+0],S=n[f+1],y=n[f+2]):(x=n[f+0]*u+r,S=n[f+1]*u+r,y=n[f+2]*u+r);for(let p=0;p<3;p++){let b,h,g;c?(b=e[l[p]](x),h=e[l[p]](S),g=e[l[p]](y)):(b=a[x+p],h=a[S+p],g=a[y+p]);let w=b;h<w&&(w=h),g<w&&(w=g);let A=b;h>A&&(A=h),g>A&&(A=g);const P=(A-w)/2,v=p*2;o[m+v+0]=w+P,o[m+v+1]=P+(Math.abs(w)+P)*Mn,w<t[p]&&(t[p]=w),A>t[p+3]&&(t[p+3]=A)}}return o}function Fn(i,t){function e(p){f&&f(p/m)}function n(p,b,h,g=null,w=0){if(!x&&w>=r&&(x=!0,u&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(i))),h<=l||w>=r)return e(b+h),p.offset=b,p.count=h,p;const A=kn(p.boundingData,g,c,b,h,d);if(A.axis===-1)return e(b+h),p.offset=b,p.count=h,p;const P=Ln(a,c,b,h,A);if(P===b||P===b+h)e(b+h),p.offset=b,p.count=h;else{p.splitAxis=A.axis;const v=new Mt,T=b,M=P-b;p.left=v,v.boundingData=new Float32Array(6),ee(c,T,M,v.boundingData,o),n(v,T,M,o,w+1);const _=new Mt,I=P,z=h-M;p.right=_,_.boundingData=new Float32Array(6),ee(c,I,z,_.boundingData,o),n(_,I,z,o,w+1)}return p}In(i,t);const s=new Float32Array(6),o=new Float32Array(6),c=En(i,s),a=i.index.array,r=t.maxDepth,u=t.verbose,l=t.maxLeafTris,d=t.strategy,f=t.onProgress,m=i.index.count/3;let x=!1;const S=[],y=zn(i);if(y.length===1){const p=y[0],b=new Mt;b.boundingData=s,Cn(c,p.offset,p.count,o),n(b,p.offset,p.count,o),S.push(b)}else for(let p of y){const b=new Mt;b.boundingData=new Float32Array(6),ee(c,p.offset,p.count,b.boundingData,o),n(b,p.offset,p.count,o),S.push(b)}return S}function Vn(i,t){const e=Fn(i,t);let n,s,o;const c=[],a=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let l=0;l<e.length;l++){const d=e[l];let f=r(d);const m=new a(Dt*f);n=new Float32Array(m),s=new Uint32Array(m),o=new Uint16Array(m),u(0,d),c.push(m)}return c;function r(l){return l.count?1:1+r(l.left)+r(l.right)}function u(l,d){const f=l/4,m=l/2,x=!!d.count,S=d.boundingData;for(let y=0;y<6;y++)n[f+y]=S[y];if(x){const y=d.offset,p=d.count;return s[f+6]=y,o[m+14]=p,o[m+15]=fe,l+Dt}else{const y=d.left,p=d.right,b=d.splitAxis;let h;if(h=u(l+Dt,y),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return s[f+6]=h/4,h=u(h,p),s[f+7]=b,h}}}class O{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,s=-1/0;for(let o=0,c=t.length;o<c;o++){const r=t[o][e];n=r<n?r:n,s=r>s?r:s}this.min=n,this.max=s}setFromPoints(t,e){let n=1/0,s=-1/0;for(let o=0,c=e.length;o<c;o++){const a=e[o],r=t.dot(a);n=r<n?r:n,s=r>s?r:s}this.min=n,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}O.prototype.setFromBox=function(){const i=new B;return function(e,n){const s=n.min,o=n.max;let c=1/0,a=-1/0;for(let r=0;r<=1;r++)for(let u=0;u<=1;u++)for(let l=0;l<=1;l++){i.x=s.x*r+o.x*(1-r),i.y=s.y*u+o.y*(1-u),i.z=s.z*l+o.z*(1-l);const d=e.dot(i);c=Math.min(d,c),a=Math.max(d,a)}this.min=c,this.max=a}}();const Dn=function(){const i=new B,t=new B,e=new B;return function(s,o,c){const a=s.start,r=i,u=o.start,l=t;e.subVectors(a,u),i.subVectors(s.end,s.start),t.subVectors(o.end,o.start);const d=e.dot(l),f=l.dot(r),m=l.dot(l),x=e.dot(r),y=r.dot(r)*m-f*f;let p,b;y!==0?p=(d*f-x*m)/y:p=0,b=(d+p*f)/m,c.x=p,c.y=b}}(),xe=function(){const i=new ut,t=new B,e=new B;return function(s,o,c,a){Dn(s,o,i);let r=i.x,u=i.y;if(r>=0&&r<=1&&u>=0&&u<=1){s.at(r,c),o.at(u,a);return}else if(r>=0&&r<=1){u<0?o.at(0,a):o.at(1,a),s.closestPointToPoint(a,!0,c);return}else if(u>=0&&u<=1){r<0?s.at(0,c):s.at(1,c),o.closestPointToPoint(c,!0,a);return}else{let l;r<0?l=s.start:l=s.end;let d;u<0?d=o.start:d=o.end;const f=t,m=e;if(s.closestPointToPoint(d,!0,t),o.closestPointToPoint(l,!0,e),f.distanceToSquared(d)<=m.distanceToSquared(l)){c.copy(f),a.copy(d);return}else{c.copy(l),a.copy(m);return}}}}(),Wn=function(){const i=new B,t=new B,e=new Ee,n=new E;return function(o,c){const{radius:a,center:r}=o,{a:u,b:l,c:d}=c;if(n.start=u,n.end=l,n.closestPointToPoint(r,!0,i).distanceTo(r)<=a||(n.start=u,n.end=d,n.closestPointToPoint(r,!0,i).distanceTo(r)<=a)||(n.start=l,n.end=d,n.closestPointToPoint(r,!0,i).distanceTo(r)<=a))return!0;const S=c.getPlane(e);if(Math.abs(S.distanceToPoint(r))<=a){const p=S.projectPoint(r,t);if(c.containsPoint(p))return!0}return!1}}(),Nn=1e-15;function ne(i){return Math.abs(i)<Nn}class H extends bt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new B),this.satBounds=new Array(4).fill().map(()=>new O),this.points=[this.a,this.b,this.c],this.sphere=new Qe,this.plane=new Ee,this.needsUpdate=!0}intersectsSphere(t){return Wn(t,this)}update(){const t=this.a,e=this.b,n=this.c,s=this.points,o=this.satAxes,c=this.satBounds,a=o[0],r=c[0];this.getNormal(a),r.setFromPoints(a,s);const u=o[1],l=c[1];u.subVectors(t,e),l.setFromPoints(u,s);const d=o[2],f=c[2];d.subVectors(e,n),f.setFromPoints(d,s);const m=o[3],x=c[3];m.subVectors(n,t),x.setFromPoints(m,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}H.prototype.closestPointToSegment=function(){const i=new B,t=new B,e=new E;return function(s,o=null,c=null){const{start:a,end:r}=s,u=this.points;let l,d=1/0;for(let f=0;f<3;f++){const m=(f+1)%3;e.start.copy(u[f]),e.end.copy(u[m]),xe(e,s,i,t),l=i.distanceToSquared(t),l<d&&(d=l,o&&o.copy(i),c&&c.copy(t))}return this.closestPointToPoint(a,i),l=a.distanceToSquared(i),l<d&&(d=l,o&&o.copy(i),c&&c.copy(a)),this.closestPointToPoint(r,i),l=r.distanceToSquared(i),l<d&&(d=l,o&&o.copy(i),c&&c.copy(r)),Math.sqrt(d)}}();H.prototype.intersectsTriangle=function(){const i=new H,t=new Array(3),e=new Array(3),n=new O,s=new O,o=new B,c=new B,a=new B,r=new B,u=new B,l=new E,d=new E,f=new E,m=new B;function x(S,y,p){const b=S.points;let h=0,g=-1;for(let w=0;w<3;w++){const{start:A,end:P}=l;A.copy(b[w]),P.copy(b[(w+1)%3]),l.delta(c);const v=ne(y.distanceToPoint(A));if(ne(y.normal.dot(c))&&v){p.copy(l),h=2;break}const T=y.intersectLine(l,m);if(!T&&v&&m.copy(A),(T||v)&&!ne(m.distanceTo(P))){if(h<=1)(h===1?p.start:p.end).copy(m),v&&(g=h);else if(h>=2){(g===1?p.start:p.end).copy(m),h=2;break}if(h++,h===2&&g===-1)break}}return h}return function(y,p=null,b=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(i.copy(y),i.update(),y=i);const h=this.plane,g=y.plane;if(Math.abs(h.normal.dot(g.normal))>1-1e-10){const w=this.satBounds,A=this.satAxes;e[0]=y.a,e[1]=y.b,e[2]=y.c;for(let T=0;T<4;T++){const M=w[T],_=A[T];if(n.setFromPoints(_,e),M.isSeparated(n))return!1}const P=y.satBounds,v=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let T=0;T<4;T++){const M=P[T],_=v[T];if(n.setFromPoints(_,t),M.isSeparated(n))return!1}for(let T=0;T<4;T++){const M=A[T];for(let _=0;_<4;_++){const I=v[_];if(o.crossVectors(M,I),n.setFromPoints(o,t),s.setFromPoints(o,e),n.isSeparated(s))return!1}}return p&&(b||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}else{const w=x(this,g,d);if(w===1&&y.containsPoint(d.end))return p&&(p.start.copy(d.end),p.end.copy(d.end)),!0;if(w!==2)return!1;const A=x(y,h,f);if(A===1&&this.containsPoint(f.end))return p&&(p.start.copy(f.end),p.end.copy(f.end)),!0;if(A!==2)return!1;if(d.delta(a),f.delta(r),a.dot(r)<0){let z=f.start;f.start=f.end,f.end=z}const P=d.start.dot(a),v=d.end.dot(a),T=f.start.dot(a),M=f.end.dot(a),_=v<T,I=P<M;return P!==M&&T!==v&&_===I?!1:(p&&(u.subVectors(d.start,f.start),u.dot(a)>0?p.start.copy(d.start):p.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(a)<0?p.end.copy(d.end):p.end.copy(f.end)),!0)}}}();H.prototype.distanceToPoint=function(){const i=new B;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}}();H.prototype.distanceToTriangle=function(){const i=new B,t=new B,e=["a","b","c"],n=new E,s=new E;return function(c,a=null,r=null){const u=a||r?n:null;if(this.intersectsTriangle(c,u))return(a||r)&&(a&&u.getCenter(a),r&&u.getCenter(r)),0;let l=1/0;for(let d=0;d<3;d++){let f;const m=e[d],x=c[m];this.closestPointToPoint(x,i),f=x.distanceToSquared(i),f<l&&(l=f,a&&a.copy(i),r&&r.copy(x));const S=this[m];c.closestPointToPoint(S,i),f=S.distanceToSquared(i),f<l&&(l=f,a&&a.copy(S),r&&r.copy(i))}for(let d=0;d<3;d++){const f=e[d],m=e[(d+1)%3];n.set(this[f],this[m]);for(let x=0;x<3;x++){const S=e[x],y=e[(x+1)%3];s.set(c[S],c[y]),xe(n,s,i,t);const p=i.distanceToSquared(t);p<l&&(l=p,a&&a.copy(i),r&&r.copy(t))}}return Math.sqrt(l)}}();class q{constructor(t,e,n){this.isOrientedBox=!0,this.min=new B,this.max=new B,this.matrix=new K,this.invMatrix=new K,this.points=new Array(8).fill().map(()=>new B),this.satAxes=new Array(3).fill().map(()=>new B),this.satBounds=new Array(3).fill().map(()=>new O),this.alignedSatBounds=new Array(3).fill().map(()=>new O),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,s=this.points;for(let u=0;u<=1;u++)for(let l=0;l<=1;l++)for(let d=0;d<=1;d++){const f=1*u|2*l|4*d,m=s[f];m.x=u?n.x:e.x,m.y=l?n.y:e.y,m.z=d?n.z:e.z,m.applyMatrix4(t)}const o=this.satBounds,c=this.satAxes,a=s[0];for(let u=0;u<3;u++){const l=c[u],d=o[u],f=1<<u,m=s[f];l.subVectors(a,m),d.setFromPoints(l,s)}const r=this.alignedSatBounds;r[0].setFromPointsField(s,"x"),r[1].setFromPointsField(s,"y"),r[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const i=new O;return function(e){this.needsUpdate&&this.update();const n=e.min,s=e.max,o=this.satBounds,c=this.satAxes,a=this.alignedSatBounds;if(i.min=n.x,i.max=s.x,a[0].isSeparated(i)||(i.min=n.y,i.max=s.y,a[1].isSeparated(i))||(i.min=n.z,i.max=s.z,a[2].isSeparated(i)))return!1;for(let r=0;r<3;r++){const u=c[r],l=o[r];if(i.setFromBox(u,e),l.isSeparated(i))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const i=new H,t=new Array(3),e=new O,n=new O,s=new B;return function(c){this.needsUpdate&&this.update(),c.isExtendedTriangle?c.needsUpdate&&c.update():(i.copy(c),i.update(),c=i);const a=this.satBounds,r=this.satAxes;t[0]=c.a,t[1]=c.b,t[2]=c.c;for(let f=0;f<3;f++){const m=a[f],x=r[f];if(e.setFromPoints(x,t),m.isSeparated(e))return!1}const u=c.satBounds,l=c.satAxes,d=this.points;for(let f=0;f<3;f++){const m=u[f],x=l[f];if(e.setFromPoints(x,d),m.isSeparated(e))return!1}for(let f=0;f<3;f++){const m=r[f];for(let x=0;x<4;x++){const S=l[x];if(s.crossVectors(m,S),e.setFromPoints(s,t),n.setFromPoints(s,d),e.isSeparated(n))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();q.prototype.distanceToPoint=function(){const i=new B;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}}();q.prototype.distanceToBox=function(){const i=["x","y","z"],t=new Array(12).fill().map(()=>new E),e=new Array(12).fill().map(()=>new E),n=new B,s=new B;return function(c,a=0,r=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(c))return(r||u)&&(c.getCenter(s),this.closestPointToPoint(s,n),c.closestPointToPoint(n,s),r&&r.copy(n),u&&u.copy(s)),0;const l=a*a,d=c.min,f=c.max,m=this.points;let x=1/0;for(let y=0;y<8;y++){const p=m[y];s.copy(p).clamp(d,f);const b=p.distanceToSquared(s);if(b<x&&(x=b,r&&r.copy(p),u&&u.copy(s),b<l))return Math.sqrt(b)}let S=0;for(let y=0;y<3;y++)for(let p=0;p<=1;p++)for(let b=0;b<=1;b++){const h=(y+1)%3,g=(y+2)%3,w=p<<h|b<<g,A=1<<y|p<<h|b<<g,P=m[w],v=m[A];t[S].set(P,v);const M=i[y],_=i[h],I=i[g],z=e[S],L=z.start,U=z.end;L[M]=d[M],L[_]=p?d[_]:f[_],L[I]=b?d[I]:f[_],U[M]=f[M],U[_]=p?d[_]:f[_],U[I]=b?d[I]:f[_],S++}for(let y=0;y<=1;y++)for(let p=0;p<=1;p++)for(let b=0;b<=1;b++){s.x=y?f.x:d.x,s.y=p?f.y:d.y,s.z=b?f.z:d.z,this.closestPointToPoint(s,n);const h=s.distanceToSquared(n);if(h<x&&(x=h,r&&r.copy(n),u&&u.copy(s),h<l))return Math.sqrt(h)}for(let y=0;y<12;y++){const p=t[y];for(let b=0;b<12;b++){const h=e[b];xe(p,h,n,s);const g=n.distanceToSquared(s);if(g<x&&(x=g,r&&r.copy(n),u&&u.copy(s),g<l))return Math.sqrt(g)}}return Math.sqrt(x)}}();const it=new B,ot=new B,rt=new B,zt=new ut,Ct=new ut,Lt=new ut,Be=new B,Me=new B,_e=new B,Ut=new B;function qn(i,t,e,n,s,o){let c;return o===tn?c=i.intersectTriangle(n,e,t,!0,s):c=i.intersectTriangle(t,e,n,o!==en,s),c===null?null:{distance:i.origin.distanceTo(s),point:s.clone()}}function jn(i,t,e,n,s,o,c,a,r){it.fromBufferAttribute(t,o),ot.fromBufferAttribute(t,c),rt.fromBufferAttribute(t,a);const u=qn(i,it,ot,rt,Ut,r);if(u){n&&(zt.fromBufferAttribute(n,o),Ct.fromBufferAttribute(n,c),Lt.fromBufferAttribute(n,a),u.uv=bt.getInterpolation(Ut,it,ot,rt,zt,Ct,Lt,new ut)),s&&(zt.fromBufferAttribute(s,o),Ct.fromBufferAttribute(s,c),Lt.fromBufferAttribute(s,a),u.uv1=bt.getInterpolation(Ut,it,ot,rt,zt,Ct,Lt,new ut)),e&&(Be.fromBufferAttribute(e,o),Me.fromBufferAttribute(e,c),_e.fromBufferAttribute(e,a),u.normal=bt.getInterpolation(Ut,it,ot,rt,Be,Me,_e,new B),u.normal.dot(i.direction)>0&&u.normal.multiplyScalar(-1));const l={a:o,b:c,c:a,normal:new B,materialIndex:0};bt.getNormal(it,ot,rt,l.normal),u.face=l,u.faceIndex=o}return u}function De(i,t,e,n,s){const o=n*3,c=i.index.getX(o),a=i.index.getX(o+1),r=i.index.getX(o+2),{position:u,normal:l,uv:d,uv1:f}=i.attributes,m=jn(e,u,l,d,f,c,a,r,t);return m?(m.faceIndex=n,s&&s.push(m),m):null}function On(i,t,e,n,s,o){for(let c=n,a=n+s;c<a;c++)De(i,t,e,c,o)}function Hn(i,t,e,n,s){let o=1/0,c=null;for(let a=n,r=n+s;a<r;a++){const u=De(i,t,e,a);u&&u.distance<o&&(c=u,o=u.distance)}return c}function W(i,t,e,n){const s=i.a,o=i.b,c=i.c;let a=t,r=t+1,u=t+2;e&&(a=e.getX(t),r=e.getX(t+1),u=e.getX(t+2)),s.x=n.getX(a),s.y=n.getY(a),s.z=n.getZ(a),o.x=n.getX(r),o.y=n.getY(r),o.z=n.getZ(r),c.x=n.getX(u),c.y=n.getY(u),c.z=n.getZ(u)}function Ie(i,t,e,n,s,o,c){const a=e.index,r=e.attributes.position;for(let u=i,l=t+i;u<l;u++)if(W(c,u*3,a,r),c.needsUpdate=!0,n(c,u,s,o))return!0;return!1}class We{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function G(i,t){return t[i+15]===65535}function ft(i,t){return t[i+6]}function St(i,t){return t[i+14]}function Tt(i){return i+8}function Pt(i,t){return t[i+6]}function Xn(i,t){return t[i+7]}const at=new et,Nt=new B,Gn=["x","y","z"];function ue(i,t,e,n,s){let o=i*2,c=dt,a=Y,r=Z;if(G(o,a)){const l=ft(i,r),d=St(o,a);On(t,e,n,l,d,s)}else{const l=Tt(i);qt(l,c,n,Nt)&&ue(l,t,e,n,s);const d=Pt(i,r);qt(d,c,n,Nt)&&ue(d,t,e,n,s)}}function de(i,t,e,n){let s=i*2,o=dt,c=Y,a=Z;if(G(s,c)){const u=ft(i,a),l=St(s,c);return Hn(t,e,n,u,l)}else{const u=Xn(i,a),l=Gn[u],f=n.direction[l]>=0;let m,x;f?(m=Tt(i),x=Pt(i,a)):(m=Pt(i,a),x=Tt(i));const y=qt(m,o,n,Nt)?de(m,t,e,n):null;if(y){const h=y.point[l];if(f?h<=o[x+u]:h>=o[x+u+3])return y}const b=qt(x,o,n,Nt)?de(x,t,e,n):null;return y&&b?y.distance<=b.distance?y:b:y||b||null}}const Yn=function(){let i,t;const e=[],n=new We(()=>new et);return function(...c){i=n.getPrimitive(),t=n.getPrimitive(),e.push(i,t);const a=s(...c);n.releasePrimitive(i),n.releasePrimitive(t),e.pop(),e.pop();const r=e.length;return r>0&&(t=e[r-1],i=e[r-2]),a};function s(o,c,a,r,u=null,l=0,d=0){function f(h){let g=h*2,w=Y,A=Z;for(;!G(g,w);)h=Tt(h),g=h*2;return ft(h,A)}function m(h){let g=h*2,w=Y,A=Z;for(;!G(g,w);)h=Pt(h,A),g=h*2;return ft(h,A)+St(g,w)}let x=o*2,S=dt,y=Y,p=Z;if(G(x,y)){const h=ft(o,p),g=St(x,y);return N(o,S,i),r(h,g,!1,d,l+o,i)}else{const h=Tt(o),g=Pt(o,p);let w=h,A=g,P,v,T,M;if(u&&(T=i,M=t,N(w,S,T),N(A,S,M),P=u(T),v=u(M),v<P)){w=g,A=h;const F=P;P=v,v=F,T=M}T||(T=i,N(w,S,T));const _=G(w*2,y),I=a(T,_,P,d+1,l+w);let z;if(I===Ae){const F=f(w),st=m(w)-F;z=r(F,st,!0,d+1,l+w,T)}else z=I&&s(w,c,a,r,u,l,d+1);if(z)return!0;M=t,N(A,S,M);const L=G(A*2,y),U=a(M,L,v,d+1,l+A);let nt;if(U===Ae){const F=f(A),st=m(A)-F;nt=r(F,st,!0,d+1,l+A,M)}else nt=U&&s(A,c,a,r,u,l,d+1);return!!nt}}}(),Zn=function(){const i=new H,t=new H,e=new K,n=new q,s=new q;return function o(c,a,r,u,l=null){let d=c*2,f=dt,m=Y,x=Z;if(l===null&&(r.boundingBox||r.computeBoundingBox(),n.set(r.boundingBox.min,r.boundingBox.max,u),l=n),G(d,m)){const y=a,p=y.index,b=y.attributes.position,h=r.index,g=r.attributes.position,w=ft(c,x),A=St(d,m);if(e.copy(u).invert(),r.boundsTree)return N(c,f,s),s.matrix.copy(e),s.needsUpdate=!0,r.boundsTree.shapecast({intersectsBounds:v=>s.intersectsBox(v),intersectsTriangle:v=>{v.a.applyMatrix4(u),v.b.applyMatrix4(u),v.c.applyMatrix4(u),v.needsUpdate=!0;for(let T=w*3,M=(A+w)*3;T<M;T+=3)if(W(t,T,p,b),t.needsUpdate=!0,v.intersectsTriangle(t))return!0;return!1}});for(let P=w*3,v=A+w*3;P<v;P+=3){W(i,P,p,b),i.a.applyMatrix4(e),i.b.applyMatrix4(e),i.c.applyMatrix4(e),i.needsUpdate=!0;for(let T=0,M=h.count;T<M;T+=3)if(W(t,T,h,g),t.needsUpdate=!0,i.intersectsTriangle(t))return!0}}else{const y=c+8,p=x[c+6];return N(y,f,at),!!(l.intersectsBox(at)&&o(y,a,r,u,l)||(N(p,f,at),l.intersectsBox(at)&&o(p,a,r,u,l)))}}}();function qt(i,t,e,n){return N(i,t,at),e.intersectBox(at,n)}const pe=[];let Wt,dt,Y,Z;function wt(i){Wt&&pe.push(Wt),Wt=i,dt=new Float32Array(i),Y=new Uint16Array(i),Z=new Uint32Array(i)}function kt(){Wt=null,dt=null,Y=null,Z=null,pe.length&&wt(pe.pop())}const se=Symbol("skip tree generation"),ie=new et,oe=new et,ct=new K,$=new q,ht=new q,yt=new B,Rt=new B,Kn=new B,$n=new B,Jn=new B,ze=new et,D=new We(()=>new H);class At{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),At.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,s=t._roots,o=n.getIndex();let c;return e.cloneBuffers?c={roots:s.map(a=>a.slice()),index:o.array.slice()}:c={roots:s,index:o.array},c}static deserialize(t,e,n={}){if(typeof n=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),At.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});n={setIndex:!0,...n};const{index:s,roots:o}=t,c=new At(e,{...n,[se]:!0});if(c._roots=o,n.setIndex){const a=e.getIndex();if(a===null){const r=new Jt(t.index,1,!1);e.setIndex(r)}else a.array!==s&&(a.array.set(s),a.needsUpdate=!0)}return c}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:Ve,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[se]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[se]||(this._roots=Vn(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new et))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,s=e.attributes.position;let o,c,a,r,u=0;const l=this._roots;for(let f=0,m=l.length;f<m;f++)o=l[f],c=new Uint32Array(o),a=new Uint16Array(o),r=new Float32Array(o),d(0,u),u+=o.byteLength;function d(f,m,x=!1){const S=f*2;if(a[S+15]===fe){const p=c[f+6],b=a[S+14];let h=1/0,g=1/0,w=1/0,A=-1/0,P=-1/0,v=-1/0;for(let T=3*p,M=3*(p+b);T<M;T++){const _=n[T],I=s.getX(_),z=s.getY(_),L=s.getZ(_);I<h&&(h=I),I>A&&(A=I),z<g&&(g=z),z>P&&(P=z),L<w&&(w=L),L>v&&(v=L)}return r[f+0]!==h||r[f+1]!==g||r[f+2]!==w||r[f+3]!==A||r[f+4]!==P||r[f+5]!==v?(r[f+0]=h,r[f+1]=g,r[f+2]=w,r[f+3]=A,r[f+4]=P,r[f+5]=v,!0):!1}else{const p=f+8,b=c[f+6],h=p+m,g=b+m;let w=x,A=!1,P=!1;t?w||(A=t.has(h),P=t.has(g),w=!A&&!P):(A=!0,P=!0);const v=w||A,T=w||P;let M=!1;v&&(M=d(p,m,w));let _=!1;T&&(_=d(b,m,w));const I=M||_;if(I)for(let z=0;z<3;z++){const L=p+z,U=b+z,nt=r[L],F=r[L+3],Bt=r[U],st=r[U+3];r[f+z]=nt<Bt?nt:Bt,r[f+z+3]=F>st?F:st}return I}}}traverse(t,e=0){const n=this._roots[e],s=new Uint32Array(n),o=new Uint16Array(n);c(0);function c(a,r=0){const u=a*2,l=o[u+15]===fe;if(l){const d=s[a+6],f=o[u+14];t(r,l,new Float32Array(n,a*4,6),d,f)}else{const d=a+Dt/4,f=s[a+6],m=s[a+7];t(r,l,new Float32Array(n,a*4,6),m)||(c(d,r+1),c(f,r+1))}}}raycast(t,e=we){const n=this._roots,s=this.geometry,o=[],c=e.isMaterial,a=Array.isArray(e),r=s.groups,u=c?e.side:e;for(let l=0,d=n.length;l<d;l++){const f=a?e[r[l].materialIndex].side:u,m=o.length;if(wt(n[l]),ue(0,s,f,t,o),kt(),a){const x=r[l].materialIndex;for(let S=m,y=o.length;S<y;S++)o[S].face.materialIndex=x}}return o}raycastFirst(t,e=we){const n=this._roots,s=this.geometry,o=e.isMaterial,c=Array.isArray(e);let a=null;const r=s.groups,u=o?e.side:e;for(let l=0,d=n.length;l<d;l++){const f=c?e[r[l].materialIndex].side:u;wt(n[l]);const m=de(0,s,f,t);kt(),m!=null&&(a==null||m.distance<a.distance)&&(a=m,c&&(m.face.materialIndex=r[l].materialIndex))}return a}intersectsGeometry(t,e){const n=this.geometry;let s=!1;for(const o of this._roots)if(wt(o),s=Zn(0,n,t,e),kt(),s)break;return s}shapecast(t,e,n){const s=this.geometry;if(t instanceof Function){if(e){const f=e;e=(m,x,S,y)=>{const p=x*3;return f(m,p,p+1,p+2,S,y)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=D.getPrimitive();let{boundsTraverseOrder:c,intersectsBounds:a,intersectsRange:r,intersectsTriangle:u}=t;if(r&&u){const f=r;r=(m,x,S,y,p)=>f(m,x,S,y,p)?!0:Ie(m,x,s,u,S,y,o)}else r||(u?r=(f,m,x,S)=>Ie(f,m,s,u,x,S,o):r=(f,m,x)=>x);let l=!1,d=0;for(const f of this._roots){if(wt(f),l=Yn(0,s,a,r,c,d),kt(),l)break;d+=f.byteLength}return D.releasePrimitive(o),l}bvhcast(t,e,n){let{intersectsRanges:s,intersectsTriangles:o}=n;const c=this.geometry.index,a=this.geometry.attributes.position,r=t.geometry.index,u=t.geometry.attributes.position;ct.copy(e).invert();const l=D.getPrimitive(),d=D.getPrimitive();if(o){let m=function(x,S,y,p,b,h,g,w){for(let A=y,P=y+p;A<P;A++){W(d,A*3,r,u),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let v=x,T=x+S;v<T;v++)if(W(l,v*3,c,a),l.needsUpdate=!0,o(l,d,v,A,b,h,g,w))return!0}return!1};if(s){const x=s;s=function(S,y,p,b,h,g,w,A){return x(S,y,p,b,h,g,w,A)?!0:m(S,y,p,b,h,g,w,A)}}else s=m}t.getBoundingBox(oe),oe.applyMatrix4(e);const f=this.shapecast({intersectsBounds:m=>oe.intersectsBox(m),intersectsRange:(m,x,S,y,p,b)=>(ie.copy(b),ie.applyMatrix4(ct),t.shapecast({intersectsBounds:h=>ie.intersectsBox(h),intersectsRange:(h,g,w,A,P)=>s(m,x,h,g,y,p,A,P)}))});return D.releasePrimitive(l),D.releasePrimitive(d),f}intersectsBox(t,e){return $.set(t.min,t.max,e),$.needsUpdate=!0,this.shapecast({intersectsBounds:n=>$.intersectsBox(n),intersectsTriangle:n=>$.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},s={},o=0,c=1/0){t.boundingBox||t.computeBoundingBox(),$.set(t.boundingBox.min,t.boundingBox.max,e),$.needsUpdate=!0;const a=this.geometry,r=a.attributes.position,u=a.index,l=t.attributes.position,d=t.index,f=D.getPrimitive(),m=D.getPrimitive();let x=Rt,S=Kn,y=null,p=null;s&&(y=$n,p=Jn);let b=1/0,h=null,g=null;return ct.copy(e).invert(),ht.matrix.copy(ct),this.shapecast({boundsTraverseOrder:w=>$.distanceToBox(w),intersectsBounds:(w,A,P)=>P<b&&P<c?(A&&(ht.min.copy(w.min),ht.max.copy(w.max),ht.needsUpdate=!0),!0):!1,intersectsRange:(w,A)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:P=>ht.distanceToBox(P),intersectsBounds:(P,v,T)=>T<b&&T<c,intersectsRange:(P,v)=>{for(let T=P*3,M=(P+v)*3;T<M;T+=3){W(m,T,d,l),m.a.applyMatrix4(e),m.b.applyMatrix4(e),m.c.applyMatrix4(e),m.needsUpdate=!0;for(let _=w*3,I=(w+A)*3;_<I;_+=3){W(f,_,u,r),f.needsUpdate=!0;const z=f.distanceToTriangle(m,x,y);if(z<b&&(S.copy(x),p&&p.copy(y),b=z,h=_/3,g=T/3),z<o)return!0}}}});{const P=d?d.count:l.count;for(let v=0,T=P;v<T;v+=3){W(m,v,d,l),m.a.applyMatrix4(e),m.b.applyMatrix4(e),m.c.applyMatrix4(e),m.needsUpdate=!0;for(let M=w*3,_=(w+A)*3;M<_;M+=3){W(f,M,u,r),f.needsUpdate=!0;const I=f.distanceToTriangle(m,x,y);if(I<b&&(S.copy(x),p&&p.copy(y),b=I,h=M/3,g=v/3),I<o)return!0}}}}}),D.releasePrimitive(f),D.releasePrimitive(m),b===1/0?null:(n.point?n.point.copy(S):n.point=S.clone(),n.distance=b,n.faceIndex=h,s&&(s.point?s.point.copy(p):s.point=p.clone(),s.point.applyMatrix4(ct),S.applyMatrix4(ct),s.distance=S.sub(s.point).length(),s.faceIndex=g),n)}closestPointToPoint(t,e={},n=0,s=1/0){const o=n*n,c=s*s;let a=1/0,r=null;if(this.shapecast({boundsTraverseOrder:l=>(yt.copy(t).clamp(l.min,l.max),yt.distanceToSquared(t)),intersectsBounds:(l,d,f)=>f<a&&f<c,intersectsTriangle:(l,d)=>{l.closestPointToPoint(t,yt);const f=t.distanceToSquared(yt);return f<a&&(Rt.copy(yt),a=f,r=d),f<o}}),a===1/0)return null;const u=Math.sqrt(a);return e.point?e.point.copy(Rt):e.point=Rt.clone(),e.distance=u,e.faceIndex=r,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{N(0,new Float32Array(n),ze),t.union(ze)}),t}}const J=new B,Q=new B,tt=new B,Ce=new ye,Et=new B,re=new B,Le=new ye,Ue=new ye,Ft=new K,ke=new K;function xt(i,t){if(!i&&!t)return;const e=i.count===t.count,n=i.normalized===t.normalized,s=i.array.constructor===t.array.constructor,o=i.itemSize===t.itemSize;if(!e||!n||!s||!o)throw new Error}function gt(i,t=null){const e=i.array.constructor,n=i.normalized,s=i.itemSize,o=t===null?i.count:t;return new Jt(new e(s*o),s,n)}function Ne(i,t,e=0){if(i.isInterleavedBufferAttribute){const n=i.itemSize;for(let s=0,o=i.count;s<o;s++){const c=s+e;t.setX(c,i.getX(s)),n>=2&&t.setY(c,i.getY(s)),n>=3&&t.setZ(c,i.getZ(s)),n>=4&&t.setW(c,i.getW(s))}}else{const n=t.array,s=n.constructor,o=n.BYTES_PER_ELEMENT*i.itemSize*e;new s(n.buffer,o,i.array.length).set(i.array)}}function Qn(i,t,e){const n=i.elements,s=t.elements;for(let o=0,c=s.length;o<c;o++)n[o]+=s[o]*e}function Re(i,t,e){const n=i.skeleton,s=i.geometry,o=n.bones,c=n.boneInverses;Le.fromBufferAttribute(s.attributes.skinIndex,t),Ue.fromBufferAttribute(s.attributes.skinWeight,t),Ft.elements.fill(0);for(let a=0;a<4;a++){const r=Ue.getComponent(a);if(r!==0){const u=Le.getComponent(a);ke.multiplyMatrices(o[u].matrixWorld,c[u]),Qn(Ft,ke,r)}}return Ft.multiply(i.bindMatrix).premultiply(i.bindMatrixInverse),e.transformDirection(Ft),e}function ce(i,t,e,n,s){Et.set(0,0,0);for(let o=0,c=i.length;o<c;o++){const a=t[o],r=i[o];a!==0&&(re.fromBufferAttribute(r,n),e?Et.addScaledVector(re,a):Et.addScaledVector(re.sub(s),a))}s.add(Et)}function ts(i,t={useGroups:!1,updateIndex:!1,skipAttributes:[]},e=new Vt){const n=i[0].index!==null,{useGroups:s=!1,updateIndex:o=!1,skipAttributes:c=[]}=t,a=new Set(Object.keys(i[0].attributes)),r={};let u=0;e.clearGroups();for(let l=0;l<i.length;++l){const d=i[l];let f=0;if(n!==(d.index!==null))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const m in d.attributes){if(!a.has(m))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+m+'" attribute exists among all geometries, or in none of them.');r[m]===void 0&&(r[m]=[]),r[m].push(d.attributes[m]),f++}if(f!==a.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(s){let m;if(n)m=d.index.count;else if(d.attributes.position!==void 0)m=d.attributes.position.count;else throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");e.addGroup(u,m,l),u+=m}}if(n){let l=!1;if(!e.index){let d=0;for(let f=0;f<i.length;++f)d+=i[f].index.count;e.setIndex(new Jt(new Uint32Array(d),1,!1)),l=!0}if(o||l){const d=e.index;let f=0,m=0;for(let x=0;x<i.length;++x){const S=i[x],y=S.index;if(c[x]!==!0)for(let p=0;p<y.count;++p)d.setX(f,y.getX(p)+m),f++;m+=S.attributes.position.count}}}for(const l in r){const d=r[l];if(!(l in e.attributes)){let x=0;for(const S in d)x+=d[S].count;e.setAttribute(l,gt(r[l][0],x))}const f=e.attributes[l];let m=0;for(let x=0,S=d.length;x<S;x++){const y=d[x];c[x]!==!0&&Ne(y,f,m),m+=y.count}}return e}function es(i,t){if(i===null||t===null)return i===t;if(i.length!==t.length)return!1;for(let e=0,n=i.length;e<n;e++)if(i[e]!==t[e])return!1;return!0}class ns{constructor(t){this.matrixWorld=new K,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=t,this.update()}update(){const t=this.mesh,e=t.geometry,n=t.skeleton,s=(e.index?e.index.count:e.attributes.position.count)/3;if(this.matrixWorld.copy(t.matrixWorld),this.geometryHash=e.attributes.position.version,this.primitiveCount=s,n){n.boneTexture||n.computeBoneTexture(),n.update();const o=n.boneMatrices;!this.boneMatrices||this.boneMatrices.length!==o.length?this.boneMatrices=o.slice():this.boneMatrices.set(o)}else this.boneMatrices=null}didChange(){const t=this.mesh,e=t.geometry,n=(e.index?e.index.count:e.attributes.position.count)/3;return!(this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===e.attributes.position.version&&es(t.skeleton&&t.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===n)}}class ss{constructor(t){Array.isArray(t)||(t=[t]);const e=[];t.forEach(n=>{n.traverseVisible(s=>{s.isMesh&&e.push(s)})}),this.meshes=e,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(e.length).fill().map(()=>new Vt),this._diffMap=new WeakMap}getMaterials(){const t=[];return this.meshes.forEach(e=>{Array.isArray(e.material)?t.push(...e.material):t.push(e.material)}),t}generate(t=new Vt){let e=[];const{meshes:n,useGroups:s,_intermediateGeometry:o,_diffMap:c}=this;for(let a=0,r=n.length;a<r;a++){const u=n[a],l=o[a],d=c.get(u);!d||d.didChange(u)?(this._convertToStaticGeometry(u,l),e.push(!1),d?d.update():c.set(u,new ns(u))):e.push(!0)}ts(o,{useGroups:s,skipAttributes:e},t);for(const a in t.attributes)t.attributes[a].needsUpdate=!0;return t}_convertToStaticGeometry(t,e=new Vt){const n=t.geometry,s=this.applyWorldTransforms,o=this.attributes.includes("normal"),c=this.attributes.includes("tangent"),a=n.attributes,r=e.attributes;e.index||(e.index=n.index),r.position||e.setAttribute("position",gt(a.position)),o&&!r.normal&&a.normal&&e.setAttribute("normal",gt(a.normal)),c&&!r.tangent&&a.tangent&&e.setAttribute("tangent",gt(a.tangent)),xt(n.index,e.index),xt(a.position,r.position),o&&xt(a.normal,r.normal),c&&xt(a.tangent,r.tangent);const u=a.position,l=o?a.normal:null,d=c?a.tangent:null,f=n.morphAttributes.position,m=n.morphAttributes.normal,x=n.morphAttributes.tangent,S=n.morphTargetsRelative,y=t.morphTargetInfluences,p=new nn;p.getNormalMatrix(t.matrixWorld);for(let b=0,h=a.position.count;b<h;b++)J.fromBufferAttribute(u,b),l&&Q.fromBufferAttribute(l,b),d&&(Ce.fromBufferAttribute(d,b),tt.fromBufferAttribute(d,b)),y&&(f&&ce(f,y,S,b,J),m&&ce(m,y,S,b,Q),x&&ce(x,y,S,b,tt)),t.isSkinnedMesh&&(t.applyBoneTransform(b,J),l&&Re(t,b,Q),d&&Re(t,b,tt)),s&&J.applyMatrix4(t.matrixWorld),r.position.setXYZ(b,J.x,J.y,J.z),l&&(s&&Q.applyNormalMatrix(p),r.normal.setXYZ(b,Q.x,Q.y,Q.z)),d&&(s&&tt.transformDirection(t.matrixWorld),r.tangent.setXYZW(b,tt.x,tt.y,tt.z,Ce.w));for(const b in this.attributes){const h=this.attributes[b];h==="position"||h==="tangent"||h==="normal"||!(h in a)||(r[h]||e.setAttribute(h,gt(a[h])),xt(a[h],r[h]),Ne(a[h],r[h]))}return e}}const is=[new URL("/WebglStudy/assets/1-91d1fd28.png",self.location).href,new URL("/WebglStudy/assets/2-577e2981.png",self.location).href,new URL("/WebglStudy/assets/3-e96f4416.jpg",self.location).href,new URL("/WebglStudy/assets/4-2c59a331.jpg",self.location).href,new URL("/WebglStudy/assets/5-c8aed110.png",self.location).href,new URL("/WebglStudy/assets/6-9d09d2dc.png",self.location).href,new URL("/WebglStudy/assets/7-68ca4bc6.png",self.location).href,new URL("/WebglStudy/assets/8-74f5f15e.jpg",self.location).href,new URL("/WebglStudy/assets/9-44142f78.jpg",self.location).href,new URL("/WebglStudy/assets/10-1cde4a43.png",self.location).href],ae={1:{title:"《小橘贝》",author:"小雅",describe:`
		它站在画面中央，静静地凝视着观众，柔和的橘色将它的柔软毛发和灵动眼眸妩媚地勾勒出来。<br>
		小猫的小耳朵微微竖起，似乎在倾听着什么，身体略微前倾，展现出它对周围世界的好奇和敏感。<br>
		画面的背景色以淡蓝色为主，这种色彩营造了温馨轻柔的氛围，让人仿佛置身于阳光明媚的午后时光中。<br>
		整个画作细致精致、色彩明亮而温暖，带给人们一种温馨、亲切的感受。
		`},2:{title:"《微光》",author:"小雅",describe:`
		微小的星光和银河组成了一个神秘的宇宙世界，让人感到无限的遐想和想象。<br>
		当你凝视着这幅画时，你会感受到无边无际的深邃和宁静。<br>
		你仿佛置身于一个没有噪音、没有烦扰的夜空中。在这个宁静的空间里，你可以看到银河中微光闪烁的样子。<br>
		这些微光似乎是夜空中唯一的生命体，它们微弱却坚定地发出光芒，点亮着整个银河系。<br>
		这些微光是如此的纤细而又强大，仿佛在无边的黑暗中，只有它们才能给人带来希望和力量。
		`},3:{title:"《天鹅》",author:"小雅",describe:`
		湖面静谧如镜，微风拂过，泛起一圈圈细微的涟漪，仿佛为优雅的白色天鹅们铺上了一层晶莹剔透的纱帐。<br>
		其中一只白羽如雪的天鹅在水中自由自在地舞动着优美的姿态，如同一位华丽的舞者在水上翩翩起舞。<br>
		纯白色羽毛在阳光的照射下，闪烁着淡淡的光晕，如同珍珠一般璀璨夺目。
		`},4:{title:"《山中小屋》",author:"小雅",describe:`
		宁静而恬淡，远山隐现于云雾中，仿佛是一幅梦幻般的画卷。<br>
		小屋在山脚下宁静地伫立，墙体洁白，屋顶泛着淡淡的阳光，使得小屋与周围的环境相互映衬。<br>
		流露出一种自然的和谐之美。
		`},5:{title:"《太空人》",author:"小雅",describe:`
		太空人身披着黑夜在星罗棋布的宇宙中漫游。<br>
		虽说现在已经是太空时代，人类早就可以坐太空飞船去月球，<br>
		但却永远无法探索别人内心的宇宙。
		`},6:{title:"《粉色海洋》",author:"小雅",describe:`
		粉色云朵蓬松如棉花糖展开眼前，弯月微笑在缝隙间，月光柔和，清雅动人。<br>
		紫色天空如梦，星辉闪烁，默默倾听，轻轻地，微风拂面，悄悄地，生命在流动。
		`},7:{title:"《风平浪静》",author:"小雅",describe:`
		撑一条船，离开岸边一百米，风平浪静，彩霞慢慢淡下去。<br>
		撑一条船，离开岸边两百米，风平浪静，夜晚轻轻呼唤你。<br>
		撑一条船，离开岸边三百米，风平浪静，大鱼笑我傻兮兮。<br>
		撑一条船 离开岸边四百米，风平浪静，星儿闪闪笑眯眯。<br>
		撑一条船 离开岸边五百米，风平浪静，海龟向我挥手臂。
		`},8:{title:"《向日葵》",author:"小雅",describe:`
		阳光照耀，金黄的花盘。<br>
		宛如一盏明灯，指引前行。<br>
		向日葵，你是信仰，你是力量，你是光辉，你是坚毅，你是忠诚，你是爱慕，你是美丽。
		`},9:{title:"《花·虎·蝶》",author:"小雅",describe:`
		一段奇妙的相遇，是自由和勇气的结合，是一份神秘而又动人的韵味。<br>
		在这片色彩斑斓的花海之中，一只带着蝴蝶翅膀的老虎，骑着踏板车，<br>
		它像是一道闪电，划破了这片美好的天地。<br>
		翅膀轻轻地振动，仿佛随时可以飞离这片美好的天地，飞向更广阔的天空。
		`},10:{title:"《豚》",author:"小雅",describe:`
		所有的转折隐藏在密集的鸟群中，天空与海洋都无法察觉，怀着美梦却可以看见。<br>
		摸索颠倒的一瞬间，所有的怀念隐藏在相似的日子里，心里的蜘蛛模仿人类张灯结彩
		`}},lt={width:window.innerWidth,height:window.innerHeight},me=xn();var jt,qe,Ot,je,Ht,Oe,Xt,He,Gt,Xe;class os{constructor(t){R(this,jt);R(this,Ot);R(this,Ht);R(this,Xt);R(this,Gt);C(this,"loader",new hn);C(this,"textureLoader",new sn);C(this,"modelOffset",new B(0,-5,0));C(this,"collisionScene");C(this,"textureBoards",{});C(this,"galleryBoards",{});C(this,"scene");this.scene=t,V(this,Gt,Xe).call(this),V(this,Ot,je).call(this);const e=[V(this,jt,qe).call(this),V(this,Ht,Oe).call(this)];Promise.all(e).then(()=>{V(this,Xt,He).call(this)})}}jt=new WeakSet,qe=function(){const{loader:t,scene:e,modelOffset:n}=this;return new Promise((s,o)=>{t.load("model/scene_collision.glb",c=>{const a=c.scene;this.collisionScene=a,a.position.add(n),a.updateMatrixWorld(!0),a.traverse(l=>{(l.name==="home001"||l.name==="PointLight")&&(l.castShadow=!0),l.name.includes("PointLight")&&l instanceof on&&(l.intensity*=2e3),l.name==="home002"&&(l.castShadow=!0,l.receiveShadow=!0),l instanceof le&&/gallery.*_board/.test(l.name)&&(this.galleryBoards[l.name]=l)});const r=new ss(this.collisionScene);r.attributes=["position"];const u=r.generate();u.boundsTree=new At(u,{lazyGeneration:!1}),me.value=new le(u),e.add(a),s(c)})})},Ot=new WeakSet,je=function(){const{loader:t,scene:e,modelOffset:n}=this;return new Promise(s=>{t.load("model/scene_desk_obj.glb",o=>{const c=o.scene;c.position.add(n),e.add(c),s(o)})})},Ht=new WeakSet,Oe=async function(){const{textureLoader:t,textureBoards:e}=this,n=[];function s(o){o.colorSpace=Fe;const c=o.image.width/o.image.height;let a=1,r=1;c>1?a=1/c:r=c,o.offset.set(.5-a/2,.5-r/2),o.repeat.set(a,r)}for(const[o,c]of is.entries()){const a=new Promise(r=>{t.load(c,u=>{s(u),e[o+1]=u,r(u)})});n.push(a)}return await Promise.all(n),e},Xt=new WeakSet,He=function(){const{textureBoards:t,galleryBoards:e}=this;for(const n in t){const s=e[`gallery${n}_board`],o=s.material;o.map=t[n],s.userData={name:s.name,title:ae[n].title,author:ae[n].author,describe:ae[n].describe,index:n,src:t[n].image.src,show_boards:!0},[4,5,6,7,9].includes(+n)&&(s.rotation.y=-Math.PI/2),+n==8&&(s.rotation.y=Math.PI)}},Gt=new WeakSet,Xe=function(){const t=new yn(new rn(100,100),{textureWidth:lt.width*window.devicePixelRatio,textureHeight:lt.height*window.devicePixelRatio,color:16777215});t.position.add(this.modelOffset),t.material instanceof cn&&(t.material.transparent=!0,t.material.fragmentShader=t.material.fragmentShader.replace("gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 )","gl_FragColor = vec4( blendOverlay( base.rgb, color ), 0.1 )")),t.rotation.x=-Math.PI/2,this.scene.add(t)};const rs=["w","W","ArrowUp"],cs=["s","S","ArrowDown"],as=["a","A","ArrowLeft"],ls=["d","D","ArrowRight"];var Yt,Zt,vt,he,Kt,Ge,$t,Ye;class fs{constructor(t,e,n){R(this,vt);R(this,Kt);R(this,$t);C(this,"moveState",{forward:!1,backward:!1,left:!1,right:!1,jump:!1});C(this,"character");C(this,"orbitController");C(this,"camera");C(this,"moveInfo",{tempVector:new B,upVector:new B(0,1,0),velocity:new B,speed:12,jumpHeight:20,gravity:-50});C(this,"capsule_info",{radius:1,segment:new E(new B,new B(0,-5,0))});C(this,"temp_box",new et);C(this,"temp_mat",new K);C(this,"temp_segment",new E);C(this,"temp_vector2",new B);R(this,Yt,t=>{V(this,vt,he).call(this,t,!0),this.moveState.jump,t.key===" "&&!this.moveState.jump&&(this.moveState.jump=!0,this.moveInfo.velocity.y=this.moveInfo.jumpHeight)});R(this,Zt,t=>{V(this,vt,he).call(this,t,!1)});C(this,"update",t=>{const{character:e,orbitController:n,camera:s}=this;V(this,Kt,Ge).call(this,t),me.value&&V(this,$t,Ye).call(this,t,me.value),s.position.sub(n.target),n.target.copy(e.position),s.position.add(e.position)});this.character=t,this.orbitController=e,this.camera=n,ge("keydown",Qt(this,Yt)),ge("keyup",Qt(this,Zt))}}Yt=new WeakMap,Zt=new WeakMap,vt=new WeakSet,he=function(t,e){if(rs.includes(t.key)){this.moveState.forward=e;return}if(cs.includes(t.key)){this.moveState.backward=e;return}if(as.includes(t.key)){this.moveState.left=e;return}if(ls.includes(t.key)){this.moveState.right=e;return}},Kt=new WeakSet,Ge=function(t){const{forward:e,backward:n,left:s,right:o,jump:c}=this.moveState;if(!(e||n||s||o||c))return;const{tempVector:a,velocity:r,speed:u,upVector:l,gravity:d}=this.moveInfo,{character:f,orbitController:m,camera:x}=this;a.set(0,0,0),e&&(a.z=-1),n&&(a.z=1),s&&(a.x=-1),o&&(a.x=1),c&&(r.y+=d*t,f.position.addScaledVector(r,t));const S=m.getAzimuthalAngle();a.applyAxisAngle(l,S),f.position.addScaledVector(a.normalize(),u*t),f.updateMatrixWorld()},$t=new WeakSet,Ye=function(t,e){var a,r;const n=this.capsule_info;this.temp_box.makeEmpty(),this.temp_mat.copy(e.matrixWorld).invert(),this.temp_segment.copy(n.segment),this.temp_segment.start.applyMatrix4(this.character.matrixWorld).applyMatrix4(this.temp_mat),this.temp_segment.end.applyMatrix4(this.character.matrixWorld).applyMatrix4(this.temp_mat),this.temp_box.expandByPoint(this.temp_segment.start),this.temp_box.expandByPoint(this.temp_segment.end),this.temp_box.min.addScalar(-n.radius),this.temp_box.max.addScalar(n.radius),(r=(a=e.geometry)==null?void 0:a.boundsTree)==null||r.shapecast({intersectsBounds:u=>u.intersectsBox(this.temp_box),intersectsTriangle:u=>{this.moveInfo.tempVector;const l=this.moveInfo.tempVector,d=this.temp_vector2,f=u.closestPointToSegment(this.temp_segment,l,d);if(f<n.radius){const m=n.radius-f,x=d.sub(l).normalize();this.temp_segment.start.addScaledVector(x,m),this.temp_segment.end.addScaledVector(x,m)}}});const s=this.moveInfo.tempVector;s.copy(this.temp_segment.start).applyMatrix4(e.matrixWorld);const o=this.temp_vector2;o.subVectors(s,this.character.position);const c=Math.max(0,o.length()-1e-5);o.normalize().multiplyScalar(c),this.character.position.add(o),o.y>Math.abs(t*this.moveInfo.velocity.y*.25)&&(this.moveState.jump=!1,this.moveInfo.velocity.set(0,0,0),this.character.position.y=0)};const ws=bn({__name:"Index",setup(i){const t=new an,e=new ln(50,lt.width/lt.height,1,9e3);e.position.set(0,0,3);const n=new fn({antialias:!0});n.setSize(lt.width,lt.height),n.setPixelRatio(window.devicePixelRatio),n.shadowMap.enabled=!0,n.outputColorSpace=Fe,n.toneMapping=un;const s=wn();gn(()=>{s.value.appendChild(n.domElement)});const o=new $e(e,n.domElement);o.minDistance=1e-4,o.maxDistance=1e-4,new os(t);const c=new le(new Pn(.5,2.5,.5,10,1),new dn({color:255}));c.geometry.translate(0,-.25,0);const a=new fs(c,o,e);t.add(c);const r=new pn;return n.setAnimationLoop(()=>{n.render(t,e),o.update();const u=r.getDelta();a.update(u)}),An(()=>{mn(t,n)}),(u,l)=>(Sn(),Tn("div",{ref_key:"containerRef",ref:s},null,512))}});export{ws as default};
