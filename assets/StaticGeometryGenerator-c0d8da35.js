import{V as v,B as Tn,e as kt,K as rt,a1 as yn,aV as N,a_ as mt,aJ as Pn,M as K,o as gn,D as Bn,y as ct,aD as Qt,d as Ft,a$ as Sn,aL as Kt}from"./three.module-0f5ed231.js";const lt=new v;function U(i,t,n,e,s,o){const c=2*Math.PI*s/4,a=Math.max(o-2*s,0),r=Math.PI/4;lt.copy(t),lt[e]=0,lt.normalize();const u=.5*c/(c+a),f=1-lt.angleTo(i)/r;return Math.sign(lt[n])===1?f*u:a/(c+a)+u+u*(1-f)}class oe extends Tn{constructor(t=1,n=1,e=1,s=2,o=.1){if(s=s*2+1,o=Math.min(t/2,n/2,e/2,o),super(1,1,1,s,s,s),s===1)return;const c=this.toNonIndexed();this.index=null,this.attributes.position=c.attributes.position,this.attributes.normal=c.attributes.normal,this.attributes.uv=c.attributes.uv;const a=new v,r=new v,u=new v(t,n,e).divideScalar(2).subScalar(o),f=this.attributes.position.array,p=this.attributes.normal.array,l=this.attributes.uv.array,m=f.length/6,x=new v,P=.5/s;for(let y=0,d=0;y<f.length;y+=3,d+=2)switch(a.fromArray(f,y),r.copy(a),r.x-=Math.sign(r.x)*P,r.y-=Math.sign(r.y)*P,r.z-=Math.sign(r.z)*P,r.normalize(),f[y+0]=u.x*Math.sign(a.x)+r.x*o,f[y+1]=u.y*Math.sign(a.y)+r.y*o,f[y+2]=u.z*Math.sign(a.z)+r.z*o,p[y+0]=r.x,p[y+1]=r.y,p[y+2]=r.z,Math.floor(y/m)){case 0:x.set(1,0,0),l[d+0]=U(x,r,"z","y",o,e),l[d+1]=1-U(x,r,"y","z",o,n);break;case 1:x.set(-1,0,0),l[d+0]=1-U(x,r,"z","y",o,e),l[d+1]=1-U(x,r,"y","z",o,n);break;case 2:x.set(0,1,0),l[d+0]=1-U(x,r,"x","z",o,t),l[d+1]=U(x,r,"z","x",o,e);break;case 3:x.set(0,-1,0),l[d+0]=1-U(x,r,"x","z",o,t),l[d+1]=1-U(x,r,"z","x",o,e);break;case 4:x.set(0,0,1),l[d+0]=1-U(x,r,"x","y",o,t),l[d+1]=1-U(x,r,"y","x",o,n);break;case 5:x.set(0,0,-1),l[d+0]=U(x,r,"x","y",o,t),l[d+1]=1-U(x,r,"y","x",o,n);break}}}const xn=0,Mn=1,vn=2,tn=2,Rt=1.25,nn=1,Ut=6*4+4+4,Zt=65535,In=Math.pow(2,-24);class Tt{constructor(){}}function D(i,t,n){return n.min.x=t[i],n.min.y=t[i+1],n.min.z=t[i+2],n.max.x=t[i+3],n.max.y=t[i+4],n.max.z=t[i+5],n}function zn(i){i[0]=i[1]=i[2]=1/0,i[3]=i[4]=i[5]=-1/0}function en(i){let t=-1,n=-1/0;for(let e=0;e<3;e++){const s=i[e+3]-i[e];s>n&&(n=s,t=e)}return t}function sn(i,t){t.set(i)}function on(i,t,n){let e,s;for(let o=0;o<3;o++){const c=o+3;e=i[o],s=t[o],n[o]=e<s?e:s,e=i[c],s=t[c],n[c]=e>s?e:s}}function Pt(i,t,n){for(let e=0;e<3;e++){const s=t[i+2*e],o=t[i+2*e+1],c=s-o,a=s+o;c<n[e]&&(n[e]=c),a>n[e+3]&&(n[e+3]=a)}}function ft(i){const t=i[3]-i[0],n=i[4]-i[1],e=i[5]-i[2];return 2*(t*n+n*e+e*t)}function Cn(i,t){if(!i.index){const n=i.attributes.position.count,e=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let s;n>65535?s=new Uint32Array(new e(4*n)):s=new Uint16Array(new e(2*n)),i.setIndex(new kt(s,1));for(let o=0;o<n;o++)s[o]=o}}function _n(i){if(!i.groups||!i.groups.length)return[{offset:0,count:i.index.count/3}];const t=[],n=new Set;for(const s of i.groups)n.add(s.start),n.add(s.start+s.count);const e=Array.from(n.values()).sort((s,o)=>s-o);for(let s=0;s<e.length-1;s++){const o=e[s],c=e[s+1];t.push({offset:o/3,count:(c-o)/3})}return t}function Nt(i,t,n,e,s=null){let o=1/0,c=1/0,a=1/0,r=-1/0,u=-1/0,f=-1/0,p=1/0,l=1/0,m=1/0,x=-1/0,P=-1/0,y=-1/0;const d=s!==null;for(let b=t*6,h=(t+n)*6;b<h;b+=6){const A=i[b+0],w=i[b+1],T=A-w,B=A+w;T<o&&(o=T),B>r&&(r=B),d&&A<p&&(p=A),d&&A>x&&(x=A);const S=i[b+2],g=i[b+3],M=S-g,I=S+g;M<c&&(c=M),I>u&&(u=I),d&&S<l&&(l=S),d&&S>P&&(P=S);const z=i[b+4],C=i[b+5],_=z-C,F=z+C;_<a&&(a=_),F>f&&(f=F),d&&z<m&&(m=z),d&&z>y&&(y=z)}e[0]=o,e[1]=c,e[2]=a,e[3]=r,e[4]=u,e[5]=f,d&&(s[0]=p,s[1]=l,s[2]=m,s[3]=x,s[4]=P,s[5]=y)}function Fn(i,t,n,e){let s=1/0,o=1/0,c=1/0,a=-1/0,r=-1/0,u=-1/0;for(let f=t*6,p=(t+n)*6;f<p;f+=6){const l=i[f+0];l<s&&(s=l),l>a&&(a=l);const m=i[f+2];m<o&&(o=m),m>r&&(r=m);const x=i[f+4];x<c&&(c=x),x>u&&(u=x)}e[0]=s,e[1]=o,e[2]=c,e[3]=a,e[4]=r,e[5]=u}function Un(i,t,n,e,s){let o=n,c=n+e-1;const a=s.pos,r=s.axis*2;for(;;){for(;o<=c&&t[o*6+r]<a;)o++;for(;o<=c&&t[c*6+r]>=a;)c--;if(o<c){for(let u=0;u<3;u++){let f=i[o*3+u];i[o*3+u]=i[c*3+u],i[c*3+u]=f;let p=t[o*6+u*2+0];t[o*6+u*2+0]=t[c*6+u*2+0],t[c*6+u*2+0]=p;let l=t[o*6+u*2+1];t[o*6+u*2+1]=t[c*6+u*2+1],t[c*6+u*2+1]=l}o++,c--}else return o}}const R=32,En=(i,t)=>i.candidate-t.candidate,W=new Array(R).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),gt=new Float32Array(6);function Ln(i,t,n,e,s,o){let c=-1,a=0;if(o===xn)c=en(t),c!==-1&&(a=(t[c]+t[c+3])/2);else if(o===Mn)c=en(i),c!==-1&&(a=Vn(n,e,s,c));else if(o===vn){const r=ft(i);let u=Rt*s;const f=e*6,p=(e+s)*6;for(let l=0;l<3;l++){const m=t[l],y=(t[l+3]-m)/R;if(s<R/4){const d=[...W];d.length=s;let b=0;for(let A=f;A<p;A+=6,b++){const w=d[b];w.candidate=n[A+2*l],w.count=0;const{bounds:T,leftCacheBounds:B,rightCacheBounds:S}=w;for(let g=0;g<3;g++)S[g]=1/0,S[g+3]=-1/0,B[g]=1/0,B[g+3]=-1/0,T[g]=1/0,T[g+3]=-1/0;Pt(A,n,T)}d.sort(En);let h=s;for(let A=0;A<h;A++){const w=d[A];for(;A+1<h&&d[A+1].candidate===w.candidate;)d.splice(A+1,1),h--}for(let A=f;A<p;A+=6){const w=n[A+2*l];for(let T=0;T<h;T++){const B=d[T];w>=B.candidate?Pt(A,n,B.rightCacheBounds):(Pt(A,n,B.leftCacheBounds),B.count++)}}for(let A=0;A<h;A++){const w=d[A],T=w.count,B=s-w.count,S=w.leftCacheBounds,g=w.rightCacheBounds;let M=0;T!==0&&(M=ft(S)/r);let I=0;B!==0&&(I=ft(g)/r);const z=nn+Rt*(M*T+I*B);z<u&&(c=l,u=z,a=w.candidate)}}else{for(let h=0;h<R;h++){const A=W[h];A.count=0,A.candidate=m+y+h*y;const w=A.bounds;for(let T=0;T<3;T++)w[T]=1/0,w[T+3]=-1/0}for(let h=f;h<p;h+=6){let T=~~((n[h+2*l]-m)/y);T>=R&&(T=R-1);const B=W[T];B.count++,Pt(h,n,B.bounds)}const d=W[R-1];sn(d.bounds,d.rightCacheBounds);for(let h=R-2;h>=0;h--){const A=W[h],w=W[h+1];on(A.bounds,w.rightCacheBounds,A.rightCacheBounds)}let b=0;for(let h=0;h<R-1;h++){const A=W[h],w=A.count,T=A.bounds,S=W[h+1].rightCacheBounds;w!==0&&(b===0?sn(T,gt):on(T,gt,gt)),b+=w;let g=0,M=0;b!==0&&(g=ft(gt)/r);const I=s-b;I!==0&&(M=ft(S)/r);const z=nn+Rt*(g*b+M*I);z<u&&(c=l,u=z,a=A.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:c,pos:a}}function Vn(i,t,n,e){let s=0;for(let o=t,c=t+n;o<c;o++)s+=i[o*6+e*2];return s/n}function Dn(i,t){zn(t);const n=i.attributes.position,e=i.index.array,s=e.length/3,o=new Float32Array(s*6),c=n.normalized,a=n.array,r=n.offset||0;let u=3;n.isInterleavedBufferAttribute&&(u=n.data.stride);const f=["getX","getY","getZ"];for(let p=0;p<s;p++){const l=p*3,m=p*6;let x,P,y;c?(x=e[l+0],P=e[l+1],y=e[l+2]):(x=e[l+0]*u+r,P=e[l+1]*u+r,y=e[l+2]*u+r);for(let d=0;d<3;d++){let b,h,A;c?(b=n[f[d]](x),h=n[f[d]](P),A=n[f[d]](y)):(b=a[x+d],h=a[P+d],A=a[y+d]);let w=b;h<w&&(w=h),A<w&&(w=A);let T=b;h>T&&(T=h),A>T&&(T=A);const B=(T-w)/2,S=d*2;o[m+S+0]=w+B,o[m+S+1]=B+(Math.abs(w)+B)*In,w<t[d]&&(t[d]=w),T>t[d+3]&&(t[d+3]=T)}}return o}function kn(i,t){function n(d){l&&l(d/m)}function e(d,b,h,A=null,w=0){if(!x&&w>=r&&(x=!0,u&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(i))),h<=f||w>=r)return n(b+h),d.offset=b,d.count=h,d;const T=Ln(d.boundingData,A,c,b,h,p);if(T.axis===-1)return n(b+h),d.offset=b,d.count=h,d;const B=Un(a,c,b,h,T);if(B===b||B===b+h)n(b+h),d.offset=b,d.count=h;else{d.splitAxis=T.axis;const S=new Tt,g=b,M=B-b;d.left=S,S.boundingData=new Float32Array(6),Nt(c,g,M,S.boundingData,o),e(S,g,M,o,w+1);const I=new Tt,z=B,C=h-M;d.right=I,I.boundingData=new Float32Array(6),Nt(c,z,C,I.boundingData,o),e(I,z,C,o,w+1)}return d}Cn(i,t);const s=new Float32Array(6),o=new Float32Array(6),c=Dn(i,s),a=i.index.array,r=t.maxDepth,u=t.verbose,f=t.maxLeafTris,p=t.strategy,l=t.onProgress,m=i.index.count/3;let x=!1;const P=[],y=_n(i);if(y.length===1){const d=y[0],b=new Tt;b.boundingData=s,Fn(c,d.offset,d.count,o),e(b,d.offset,d.count,o),P.push(b)}else for(let d of y){const b=new Tt;b.boundingData=new Float32Array(6),Nt(c,d.offset,d.count,b.boundingData,o),e(b,d.offset,d.count,o),P.push(b)}return P}function Rn(i,t){const n=kn(i,t);let e,s,o;const c=[],a=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let f=0;f<n.length;f++){const p=n[f];let l=r(p);const m=new a(Ut*l);e=new Float32Array(m),s=new Uint32Array(m),o=new Uint16Array(m),u(0,p),c.push(m)}return c;function r(f){return f.count?1:1+r(f.left)+r(f.right)}function u(f,p){const l=f/4,m=f/2,x=!!p.count,P=p.boundingData;for(let y=0;y<6;y++)e[l+y]=P[y];if(x){const y=p.offset,d=p.count;return s[l+6]=y,o[m+14]=d,o[m+15]=Zt,f+Ut}else{const y=p.left,d=p.right,b=p.splitAxis;let h;if(h=u(f+Ut,y),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return s[l+6]=h/4,h=u(h,d),s[l+7]=b,h}}}class q{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,n){let e=1/0,s=-1/0;for(let o=0,c=t.length;o<c;o++){const r=t[o][n];e=r<e?r:e,s=r>s?r:s}this.min=e,this.max=s}setFromPoints(t,n){let e=1/0,s=-1/0;for(let o=0,c=n.length;o<c;o++){const a=n[o],r=t.dot(a);e=r<e?r:e,s=r>s?r:s}this.min=e,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}q.prototype.setFromBox=function(){const i=new v;return function(n,e){const s=e.min,o=e.max;let c=1/0,a=-1/0;for(let r=0;r<=1;r++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){i.x=s.x*r+o.x*(1-r),i.y=s.y*u+o.y*(1-u),i.z=s.z*f+o.z*(1-f);const p=n.dot(i);c=Math.min(p,c),a=Math.max(p,a)}this.min=c,this.max=a}}();const Nn=function(){const i=new v,t=new v,n=new v;return function(s,o,c){const a=s.start,r=i,u=o.start,f=t;n.subVectors(a,u),i.subVectors(s.end,s.start),t.subVectors(o.end,o.start);const p=n.dot(f),l=f.dot(r),m=f.dot(f),x=n.dot(r),y=r.dot(r)*m-l*l;let d,b;y!==0?d=(p*l-x*m)/y:d=0,b=(p+d*l)/m,c.x=d,c.y=b}}(),Jt=function(){const i=new rt,t=new v,n=new v;return function(s,o,c,a){Nn(s,o,i);let r=i.x,u=i.y;if(r>=0&&r<=1&&u>=0&&u<=1){s.at(r,c),o.at(u,a);return}else if(r>=0&&r<=1){u<0?o.at(0,a):o.at(1,a),s.closestPointToPoint(a,!0,c);return}else if(u>=0&&u<=1){r<0?s.at(0,c):s.at(1,c),o.closestPointToPoint(c,!0,a);return}else{let f;r<0?f=s.start:f=s.end;let p;u<0?p=o.start:p=o.end;const l=t,m=n;if(s.closestPointToPoint(p,!0,t),o.closestPointToPoint(f,!0,n),l.distanceToSquared(p)<=m.distanceToSquared(f)){c.copy(l),a.copy(p);return}else{c.copy(f),a.copy(m);return}}}}(),qn=function(){const i=new v,t=new v,n=new yn,e=new N;return function(o,c){const{radius:a,center:r}=o,{a:u,b:f,c:p}=c;if(e.start=u,e.end=f,e.closestPointToPoint(r,!0,i).distanceTo(r)<=a||(e.start=u,e.end=p,e.closestPointToPoint(r,!0,i).distanceTo(r)<=a)||(e.start=f,e.end=p,e.closestPointToPoint(r,!0,i).distanceTo(r)<=a))return!0;const P=c.getPlane(n);if(Math.abs(P.distanceToPoint(r))<=a){const d=P.projectPoint(r,t);if(c.containsPoint(d))return!0}return!1}}(),Xn=1e-15;function qt(i){return Math.abs(i)<Xn}class X extends mt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new v),this.satBounds=new Array(4).fill().map(()=>new q),this.points=[this.a,this.b,this.c],this.sphere=new Pn,this.plane=new yn,this.needsUpdate=!0}intersectsSphere(t){return qn(t,this)}update(){const t=this.a,n=this.b,e=this.c,s=this.points,o=this.satAxes,c=this.satBounds,a=o[0],r=c[0];this.getNormal(a),r.setFromPoints(a,s);const u=o[1],f=c[1];u.subVectors(t,n),f.setFromPoints(u,s);const p=o[2],l=c[2];p.subVectors(n,e),l.setFromPoints(p,s);const m=o[3],x=c[3];m.subVectors(e,t),x.setFromPoints(m,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}X.prototype.closestPointToSegment=function(){const i=new v,t=new v,n=new N;return function(s,o=null,c=null){const{start:a,end:r}=s,u=this.points;let f,p=1/0;for(let l=0;l<3;l++){const m=(l+1)%3;n.start.copy(u[l]),n.end.copy(u[m]),Jt(n,s,i,t),f=i.distanceToSquared(t),f<p&&(p=f,o&&o.copy(i),c&&c.copy(t))}return this.closestPointToPoint(a,i),f=a.distanceToSquared(i),f<p&&(p=f,o&&o.copy(i),c&&c.copy(a)),this.closestPointToPoint(r,i),f=r.distanceToSquared(i),f<p&&(p=f,o&&o.copy(i),c&&c.copy(r)),Math.sqrt(p)}}();X.prototype.intersectsTriangle=function(){const i=new X,t=new Array(3),n=new Array(3),e=new q,s=new q,o=new v,c=new v,a=new v,r=new v,u=new v,f=new N,p=new N,l=new N,m=new v;function x(P,y,d){const b=P.points;let h=0,A=-1;for(let w=0;w<3;w++){const{start:T,end:B}=f;T.copy(b[w]),B.copy(b[(w+1)%3]),f.delta(c);const S=qt(y.distanceToPoint(T));if(qt(y.normal.dot(c))&&S){d.copy(f),h=2;break}const g=y.intersectLine(f,m);if(!g&&S&&m.copy(T),(g||S)&&!qt(m.distanceTo(B))){if(h<=1)(h===1?d.start:d.end).copy(m),S&&(A=h);else if(h>=2){(A===1?d.start:d.end).copy(m),h=2;break}if(h++,h===2&&A===-1)break}}return h}return function(y,d=null,b=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(i.copy(y),i.update(),y=i);const h=this.plane,A=y.plane;if(Math.abs(h.normal.dot(A.normal))>1-1e-10){const w=this.satBounds,T=this.satAxes;n[0]=y.a,n[1]=y.b,n[2]=y.c;for(let g=0;g<4;g++){const M=w[g],I=T[g];if(e.setFromPoints(I,n),M.isSeparated(e))return!1}const B=y.satBounds,S=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let g=0;g<4;g++){const M=B[g],I=S[g];if(e.setFromPoints(I,t),M.isSeparated(e))return!1}for(let g=0;g<4;g++){const M=T[g];for(let I=0;I<4;I++){const z=S[I];if(o.crossVectors(M,z),e.setFromPoints(o,t),s.setFromPoints(o,n),e.isSeparated(s))return!1}}return d&&(b||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const w=x(this,A,p);if(w===1&&y.containsPoint(p.end))return d&&(d.start.copy(p.end),d.end.copy(p.end)),!0;if(w!==2)return!1;const T=x(y,h,l);if(T===1&&this.containsPoint(l.end))return d&&(d.start.copy(l.end),d.end.copy(l.end)),!0;if(T!==2)return!1;if(p.delta(a),l.delta(r),a.dot(r)<0){let C=l.start;l.start=l.end,l.end=C}const B=p.start.dot(a),S=p.end.dot(a),g=l.start.dot(a),M=l.end.dot(a),I=S<g,z=B<M;return B!==M&&g!==S&&I===z?!1:(d&&(u.subVectors(p.start,l.start),u.dot(a)>0?d.start.copy(p.start):d.start.copy(l.start),u.subVectors(p.end,l.end),u.dot(a)<0?d.end.copy(p.end):d.end.copy(l.end)),!0)}}}();X.prototype.distanceToPoint=function(){const i=new v;return function(n){return this.closestPointToPoint(n,i),n.distanceTo(i)}}();X.prototype.distanceToTriangle=function(){const i=new v,t=new v,n=["a","b","c"],e=new N,s=new N;return function(c,a=null,r=null){const u=a||r?e:null;if(this.intersectsTriangle(c,u))return(a||r)&&(a&&u.getCenter(a),r&&u.getCenter(r)),0;let f=1/0;for(let p=0;p<3;p++){let l;const m=n[p],x=c[m];this.closestPointToPoint(x,i),l=x.distanceToSquared(i),l<f&&(f=l,a&&a.copy(i),r&&r.copy(x));const P=this[m];c.closestPointToPoint(P,i),l=P.distanceToSquared(i),l<f&&(f=l,a&&a.copy(P),r&&r.copy(i))}for(let p=0;p<3;p++){const l=n[p],m=n[(p+1)%3];e.set(this[l],this[m]);for(let x=0;x<3;x++){const P=n[x],y=n[(x+1)%3];s.set(c[P],c[y]),Jt(e,s,i,t);const d=i.distanceToSquared(t);d<f&&(f=d,a&&a.copy(i),r&&r.copy(t))}}return Math.sqrt(f)}}();class k{constructor(t,n,e){this.isOrientedBox=!0,this.min=new v,this.max=new v,this.matrix=new K,this.invMatrix=new K,this.points=new Array(8).fill().map(()=>new v),this.satAxes=new Array(3).fill().map(()=>new v),this.satBounds=new Array(3).fill().map(()=>new q),this.alignedSatBounds=new Array(3).fill().map(()=>new q),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),e&&this.matrix.copy(e)}set(t,n,e){this.min.copy(t),this.max.copy(n),this.matrix.copy(e),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}k.prototype.update=function(){return function(){const t=this.matrix,n=this.min,e=this.max,s=this.points;for(let u=0;u<=1;u++)for(let f=0;f<=1;f++)for(let p=0;p<=1;p++){const l=1*u|2*f|4*p,m=s[l];m.x=u?e.x:n.x,m.y=f?e.y:n.y,m.z=p?e.z:n.z,m.applyMatrix4(t)}const o=this.satBounds,c=this.satAxes,a=s[0];for(let u=0;u<3;u++){const f=c[u],p=o[u],l=1<<u,m=s[l];f.subVectors(a,m),p.setFromPoints(f,s)}const r=this.alignedSatBounds;r[0].setFromPointsField(s,"x"),r[1].setFromPointsField(s,"y"),r[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();k.prototype.intersectsBox=function(){const i=new q;return function(n){this.needsUpdate&&this.update();const e=n.min,s=n.max,o=this.satBounds,c=this.satAxes,a=this.alignedSatBounds;if(i.min=e.x,i.max=s.x,a[0].isSeparated(i)||(i.min=e.y,i.max=s.y,a[1].isSeparated(i))||(i.min=e.z,i.max=s.z,a[2].isSeparated(i)))return!1;for(let r=0;r<3;r++){const u=c[r],f=o[r];if(i.setFromBox(u,n),f.isSeparated(i))return!1}return!0}}();k.prototype.intersectsTriangle=function(){const i=new X,t=new Array(3),n=new q,e=new q,s=new v;return function(c){this.needsUpdate&&this.update(),c.isExtendedTriangle?c.needsUpdate&&c.update():(i.copy(c),i.update(),c=i);const a=this.satBounds,r=this.satAxes;t[0]=c.a,t[1]=c.b,t[2]=c.c;for(let l=0;l<3;l++){const m=a[l],x=r[l];if(n.setFromPoints(x,t),m.isSeparated(n))return!1}const u=c.satBounds,f=c.satAxes,p=this.points;for(let l=0;l<3;l++){const m=u[l],x=f[l];if(n.setFromPoints(x,p),m.isSeparated(n))return!1}for(let l=0;l<3;l++){const m=r[l];for(let x=0;x<4;x++){const P=f[x];if(s.crossVectors(m,P),n.setFromPoints(s,t),e.setFromPoints(s,p),n.isSeparated(e))return!1}}return!0}}();k.prototype.closestPointToPoint=function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}}();k.prototype.distanceToPoint=function(){const i=new v;return function(n){return this.closestPointToPoint(n,i),n.distanceTo(i)}}();k.prototype.distanceToBox=function(){const i=["x","y","z"],t=new Array(12).fill().map(()=>new N),n=new Array(12).fill().map(()=>new N),e=new v,s=new v;return function(c,a=0,r=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(c))return(r||u)&&(c.getCenter(s),this.closestPointToPoint(s,e),c.closestPointToPoint(e,s),r&&r.copy(e),u&&u.copy(s)),0;const f=a*a,p=c.min,l=c.max,m=this.points;let x=1/0;for(let y=0;y<8;y++){const d=m[y];s.copy(d).clamp(p,l);const b=d.distanceToSquared(s);if(b<x&&(x=b,r&&r.copy(d),u&&u.copy(s),b<f))return Math.sqrt(b)}let P=0;for(let y=0;y<3;y++)for(let d=0;d<=1;d++)for(let b=0;b<=1;b++){const h=(y+1)%3,A=(y+2)%3,w=d<<h|b<<A,T=1<<y|d<<h|b<<A,B=m[w],S=m[T];t[P].set(B,S);const M=i[y],I=i[h],z=i[A],C=n[P],_=C.start,F=C.end;_[M]=p[M],_[I]=d?p[I]:l[I],_[z]=b?p[z]:l[I],F[M]=l[M],F[I]=d?p[I]:l[I],F[z]=b?p[z]:l[I],P++}for(let y=0;y<=1;y++)for(let d=0;d<=1;d++)for(let b=0;b<=1;b++){s.x=y?l.x:p.x,s.y=d?l.y:p.y,s.z=b?l.z:p.z,this.closestPointToPoint(s,e);const h=s.distanceToSquared(e);if(h<x&&(x=h,r&&r.copy(e),u&&u.copy(s),h<f))return Math.sqrt(h)}for(let y=0;y<12;y++){const d=t[y];for(let b=0;b<12;b++){const h=n[b];Jt(d,h,e,s);const A=e.distanceToSquared(s);if(A<x&&(x=A,r&&r.copy(e),u&&u.copy(s),A<f))return Math.sqrt(A)}}return Math.sqrt(x)}}();const tt=new v,nt=new v,et=new v,Bt=new rt,St=new rt,Mt=new rt,rn=new v,cn=new v,an=new v,vt=new v;function Wn(i,t,n,e,s,o){let c;return o===gn?c=i.intersectTriangle(e,n,t,!0,s):c=i.intersectTriangle(t,n,e,o!==Bn,s),c===null?null:{distance:i.origin.distanceTo(s),point:s.clone()}}function On(i,t,n,e,s,o,c,a,r){tt.fromBufferAttribute(t,o),nt.fromBufferAttribute(t,c),et.fromBufferAttribute(t,a);const u=Wn(i,tt,nt,et,vt,r);if(u){e&&(Bt.fromBufferAttribute(e,o),St.fromBufferAttribute(e,c),Mt.fromBufferAttribute(e,a),u.uv=mt.getInterpolation(vt,tt,nt,et,Bt,St,Mt,new rt)),s&&(Bt.fromBufferAttribute(s,o),St.fromBufferAttribute(s,c),Mt.fromBufferAttribute(s,a),u.uv1=mt.getInterpolation(vt,tt,nt,et,Bt,St,Mt,new rt)),n&&(rn.fromBufferAttribute(n,o),cn.fromBufferAttribute(n,c),an.fromBufferAttribute(n,a),u.normal=mt.getInterpolation(vt,tt,nt,et,rn,cn,an,new v),u.normal.dot(i.direction)>0&&u.normal.multiplyScalar(-1));const f={a:o,b:c,c:a,normal:new v,materialIndex:0};mt.getNormal(tt,nt,et,f.normal),u.face=f,u.faceIndex=o}return u}function bn(i,t,n,e,s){const o=e*3,c=i.index.getX(o),a=i.index.getX(o+1),r=i.index.getX(o+2),{position:u,normal:f,uv:p,uv1:l}=i.attributes,m=On(n,u,f,p,l,c,a,r,t);return m?(m.faceIndex=e,s&&s.push(m),m):null}function Hn(i,t,n,e,s,o){for(let c=e,a=e+s;c<a;c++)bn(i,t,n,c,o)}function Yn(i,t,n,e,s){let o=1/0,c=null;for(let a=e,r=e+s;a<r;a++){const u=bn(i,t,n,a);u&&u.distance<o&&(c=u,o=u.distance)}return c}function V(i,t,n,e){const s=i.a,o=i.b,c=i.c;let a=t,r=t+1,u=t+2;n&&(a=n.getX(t),r=n.getX(t+1),u=n.getX(t+2)),s.x=e.getX(a),s.y=e.getY(a),s.z=e.getZ(a),o.x=e.getX(r),o.y=e.getY(r),o.z=e.getZ(r),c.x=e.getX(u),c.y=e.getY(u),c.z=e.getZ(u)}function ln(i,t,n,e,s,o,c){const a=n.index,r=n.attributes.position;for(let u=i,f=t+i;u<f;u++)if(V(c,u*3,a,r),c.needsUpdate=!0,e(c,u,s,o))return!0;return!1}class wn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function O(i,t){return t[i+15]===65535}function ot(i,t){return t[i+6]}function xt(i,t){return t[i+14]}function bt(i){return i+8}function wt(i,t){return t[i+6]}function Zn(i,t){return t[i+7]}const it=new ct,Vt=new v,jn=["x","y","z"];function jt(i,t,n,e,s){let o=i*2,c=at,a=H,r=Y;if(O(o,a)){const f=ot(i,r),p=xt(o,a);Hn(t,n,e,f,p,s)}else{const f=bt(i);Dt(f,c,e,Vt)&&jt(f,t,n,e,s);const p=wt(i,r);Dt(p,c,e,Vt)&&jt(p,t,n,e,s)}}function Gt(i,t,n,e){let s=i*2,o=at,c=H,a=Y;if(O(s,c)){const u=ot(i,a),f=xt(s,c);return Yn(t,n,e,u,f)}else{const u=Zn(i,a),f=jn[u],l=e.direction[f]>=0;let m,x;l?(m=bt(i),x=wt(i,a)):(m=wt(i,a),x=bt(i));const y=Dt(m,o,e,Vt)?Gt(m,t,n,e):null;if(y){const h=y.point[f];if(l?h<=o[x+u]:h>=o[x+u+3])return y}const b=Dt(x,o,e,Vt)?Gt(x,t,n,e):null;return y&&b?y.distance<=b.distance?y:b:y||b||null}}const Gn=function(){let i,t;const n=[],e=new wn(()=>new ct);return function(...c){i=e.getPrimitive(),t=e.getPrimitive(),n.push(i,t);const a=s(...c);e.releasePrimitive(i),e.releasePrimitive(t),n.pop(),n.pop();const r=n.length;return r>0&&(t=n[r-1],i=n[r-2]),a};function s(o,c,a,r,u=null,f=0,p=0){function l(h){let A=h*2,w=H,T=Y;for(;!O(A,w);)h=bt(h),A=h*2;return ot(h,T)}function m(h){let A=h*2,w=H,T=Y;for(;!O(A,w);)h=wt(h,T),A=h*2;return ot(h,T)+xt(A,w)}let x=o*2,P=at,y=H,d=Y;if(O(x,y)){const h=ot(o,d),A=xt(x,y);return D(o,P,i),r(h,A,!1,p,f+o,i)}else{const h=bt(o),A=wt(o,d);let w=h,T=A,B,S,g,M;if(u&&(g=i,M=t,D(w,P,g),D(T,P,M),B=u(g),S=u(M),S<B)){w=A,T=h;const E=B;B=S,S=E,g=M}g||(g=i,D(w,P,g));const I=O(w*2,y),z=a(g,I,B,p+1,f+w);let C;if(z===tn){const E=l(w),Q=m(w)-E;C=r(E,Q,!0,p+1,f+w,g)}else C=z&&s(w,c,a,r,u,f,p+1);if(C)return!0;M=t,D(T,P,M);const _=O(T*2,y),F=a(M,_,S,p+1,f+T);let J;if(F===tn){const E=l(T),Q=m(T)-E;J=r(E,Q,!0,p+1,f+T,M)}else J=F&&s(T,c,a,r,u,f,p+1);return!!J}}}(),$n=function(){const i=new X,t=new X,n=new K,e=new k,s=new k;return function o(c,a,r,u,f=null){let p=c*2,l=at,m=H,x=Y;if(f===null&&(r.boundingBox||r.computeBoundingBox(),e.set(r.boundingBox.min,r.boundingBox.max,u),f=e),O(p,m)){const y=a,d=y.index,b=y.attributes.position,h=r.index,A=r.attributes.position,w=ot(c,x),T=xt(p,m);if(n.copy(u).invert(),r.boundsTree)return D(c,l,s),s.matrix.copy(n),s.needsUpdate=!0,r.boundsTree.shapecast({intersectsBounds:S=>s.intersectsBox(S),intersectsTriangle:S=>{S.a.applyMatrix4(u),S.b.applyMatrix4(u),S.c.applyMatrix4(u),S.needsUpdate=!0;for(let g=w*3,M=(T+w)*3;g<M;g+=3)if(V(t,g,d,b),t.needsUpdate=!0,S.intersectsTriangle(t))return!0;return!1}});for(let B=w*3,S=T+w*3;B<S;B+=3){V(i,B,d,b),i.a.applyMatrix4(n),i.b.applyMatrix4(n),i.c.applyMatrix4(n),i.needsUpdate=!0;for(let g=0,M=h.count;g<M;g+=3)if(V(t,g,h,A),t.needsUpdate=!0,i.intersectsTriangle(t))return!0}}else{const y=c+8,d=x[c+6];return D(y,l,it),!!(f.intersectsBox(it)&&o(y,a,r,u,f)||(D(d,l,it),f.intersectsBox(it)&&o(d,a,r,u,f)))}}}();function Dt(i,t,n,e){return D(i,t,it),n.intersectBox(it,e)}const $t=[];let Et,at,H,Y;function ht(i){Et&&$t.push(Et),Et=i,at=new Float32Array(i),H=new Uint16Array(i),Y=new Uint32Array(i)}function It(){Et=null,at=null,H=null,Y=null,$t.length&&ht($t.pop())}const Xt=Symbol("skip tree generation"),Wt=new ct,Ot=new ct,st=new K,Z=new k,ut=new k,pt=new v,zt=new v,Kn=new v,Jn=new v,Qn=new v,fn=new ct,L=new wn(()=>new X);class Lt{static serialize(t,n={}){if(n.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),Lt.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});n={cloneBuffers:!0,...n};const e=t.geometry,s=t._roots,o=e.getIndex();let c;return n.cloneBuffers?c={roots:s.map(a=>a.slice()),index:o.array.slice()}:c={roots:s,index:o.array},c}static deserialize(t,n,e={}){if(typeof e=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),Lt.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});e={setIndex:!0,...e};const{index:s,roots:o}=t,c=new Lt(n,{...e,[Xt]:!0});if(c._roots=o,e.setIndex){const a=n.getIndex();if(a===null){const r=new kt(t.index,1,!1);n.setIndex(r)}else a.array!==s&&(a.array.set(s),a.needsUpdate=!0)}return c}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(n=Object.assign({strategy:xn,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[Xt]:!1},n),n.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,n[Xt]||(this._roots=Rn(t,n),!t.boundingBox&&n.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new ct))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=this.geometry,e=n.index.array,s=n.attributes.position;let o,c,a,r,u=0;const f=this._roots;for(let l=0,m=f.length;l<m;l++)o=f[l],c=new Uint32Array(o),a=new Uint16Array(o),r=new Float32Array(o),p(0,u),u+=o.byteLength;function p(l,m,x=!1){const P=l*2;if(a[P+15]===Zt){const d=c[l+6],b=a[P+14];let h=1/0,A=1/0,w=1/0,T=-1/0,B=-1/0,S=-1/0;for(let g=3*d,M=3*(d+b);g<M;g++){const I=e[g],z=s.getX(I),C=s.getY(I),_=s.getZ(I);z<h&&(h=z),z>T&&(T=z),C<A&&(A=C),C>B&&(B=C),_<w&&(w=_),_>S&&(S=_)}return r[l+0]!==h||r[l+1]!==A||r[l+2]!==w||r[l+3]!==T||r[l+4]!==B||r[l+5]!==S?(r[l+0]=h,r[l+1]=A,r[l+2]=w,r[l+3]=T,r[l+4]=B,r[l+5]=S,!0):!1}else{const d=l+8,b=c[l+6],h=d+m,A=b+m;let w=x,T=!1,B=!1;t?w||(T=t.has(h),B=t.has(A),w=!T&&!B):(T=!0,B=!0);const S=w||T,g=w||B;let M=!1;S&&(M=p(d,m,w));let I=!1;g&&(I=p(b,m,w));const z=M||I;if(z)for(let C=0;C<3;C++){const _=d+C,F=b+C,J=r[_],E=r[_+3],At=r[F],Q=r[F+3];r[l+C]=J<At?J:At,r[l+C+3]=E>Q?E:Q}return z}}}traverse(t,n=0){const e=this._roots[n],s=new Uint32Array(e),o=new Uint16Array(e);c(0);function c(a,r=0){const u=a*2,f=o[u+15]===Zt;if(f){const p=s[a+6],l=o[u+14];t(r,f,new Float32Array(e,a*4,6),p,l)}else{const p=a+Ut/4,l=s[a+6],m=s[a+7];t(r,f,new Float32Array(e,a*4,6),m)||(c(p,r+1),c(l,r+1))}}}raycast(t,n=Qt){const e=this._roots,s=this.geometry,o=[],c=n.isMaterial,a=Array.isArray(n),r=s.groups,u=c?n.side:n;for(let f=0,p=e.length;f<p;f++){const l=a?n[r[f].materialIndex].side:u,m=o.length;if(ht(e[f]),jt(0,s,l,t,o),It(),a){const x=r[f].materialIndex;for(let P=m,y=o.length;P<y;P++)o[P].face.materialIndex=x}}return o}raycastFirst(t,n=Qt){const e=this._roots,s=this.geometry,o=n.isMaterial,c=Array.isArray(n);let a=null;const r=s.groups,u=o?n.side:n;for(let f=0,p=e.length;f<p;f++){const l=c?n[r[f].materialIndex].side:u;ht(e[f]);const m=Gt(0,s,l,t);It(),m!=null&&(a==null||m.distance<a.distance)&&(a=m,c&&(m.face.materialIndex=r[f].materialIndex))}return a}intersectsGeometry(t,n){const e=this.geometry;let s=!1;for(const o of this._roots)if(ht(o),s=$n(0,e,t,n),It(),s)break;return s}shapecast(t,n,e){const s=this.geometry;if(t instanceof Function){if(n){const l=n;n=(m,x,P,y)=>{const d=x*3;return l(m,d,d+1,d+2,P,y)}}t={boundsTraverseOrder:e,intersectsBounds:t,intersectsTriangle:n,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=L.getPrimitive();let{boundsTraverseOrder:c,intersectsBounds:a,intersectsRange:r,intersectsTriangle:u}=t;if(r&&u){const l=r;r=(m,x,P,y,d)=>l(m,x,P,y,d)?!0:ln(m,x,s,u,P,y,o)}else r||(u?r=(l,m,x,P)=>ln(l,m,s,u,x,P,o):r=(l,m,x)=>x);let f=!1,p=0;for(const l of this._roots){if(ht(l),f=Gn(0,s,a,r,c,p),It(),f)break;p+=l.byteLength}return L.releasePrimitive(o),f}bvhcast(t,n,e){let{intersectsRanges:s,intersectsTriangles:o}=e;const c=this.geometry.index,a=this.geometry.attributes.position,r=t.geometry.index,u=t.geometry.attributes.position;st.copy(n).invert();const f=L.getPrimitive(),p=L.getPrimitive();if(o){let m=function(x,P,y,d,b,h,A,w){for(let T=y,B=y+d;T<B;T++){V(p,T*3,r,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let S=x,g=x+P;S<g;S++)if(V(f,S*3,c,a),f.needsUpdate=!0,o(f,p,S,T,b,h,A,w))return!0}return!1};if(s){const x=s;s=function(P,y,d,b,h,A,w,T){return x(P,y,d,b,h,A,w,T)?!0:m(P,y,d,b,h,A,w,T)}}else s=m}t.getBoundingBox(Ot),Ot.applyMatrix4(n);const l=this.shapecast({intersectsBounds:m=>Ot.intersectsBox(m),intersectsRange:(m,x,P,y,d,b)=>(Wt.copy(b),Wt.applyMatrix4(st),t.shapecast({intersectsBounds:h=>Wt.intersectsBox(h),intersectsRange:(h,A,w,T,B)=>s(m,x,h,A,y,d,T,B)}))});return L.releasePrimitive(f),L.releasePrimitive(p),l}intersectsBox(t,n){return Z.set(t.min,t.max,n),Z.needsUpdate=!0,this.shapecast({intersectsBounds:e=>Z.intersectsBox(e),intersectsTriangle:e=>Z.intersectsTriangle(e)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,e={},s={},o=0,c=1/0){t.boundingBox||t.computeBoundingBox(),Z.set(t.boundingBox.min,t.boundingBox.max,n),Z.needsUpdate=!0;const a=this.geometry,r=a.attributes.position,u=a.index,f=t.attributes.position,p=t.index,l=L.getPrimitive(),m=L.getPrimitive();let x=zt,P=Kn,y=null,d=null;s&&(y=Jn,d=Qn);let b=1/0,h=null,A=null;return st.copy(n).invert(),ut.matrix.copy(st),this.shapecast({boundsTraverseOrder:w=>Z.distanceToBox(w),intersectsBounds:(w,T,B)=>B<b&&B<c?(T&&(ut.min.copy(w.min),ut.max.copy(w.max),ut.needsUpdate=!0),!0):!1,intersectsRange:(w,T)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:B=>ut.distanceToBox(B),intersectsBounds:(B,S,g)=>g<b&&g<c,intersectsRange:(B,S)=>{for(let g=B*3,M=(B+S)*3;g<M;g+=3){V(m,g,p,f),m.a.applyMatrix4(n),m.b.applyMatrix4(n),m.c.applyMatrix4(n),m.needsUpdate=!0;for(let I=w*3,z=(w+T)*3;I<z;I+=3){V(l,I,u,r),l.needsUpdate=!0;const C=l.distanceToTriangle(m,x,y);if(C<b&&(P.copy(x),d&&d.copy(y),b=C,h=I/3,A=g/3),C<o)return!0}}}});{const B=p?p.count:f.count;for(let S=0,g=B;S<g;S+=3){V(m,S,p,f),m.a.applyMatrix4(n),m.b.applyMatrix4(n),m.c.applyMatrix4(n),m.needsUpdate=!0;for(let M=w*3,I=(w+T)*3;M<I;M+=3){V(l,M,u,r),l.needsUpdate=!0;const z=l.distanceToTriangle(m,x,y);if(z<b&&(P.copy(x),d&&d.copy(y),b=z,h=M/3,A=S/3),z<o)return!0}}}}}),L.releasePrimitive(l),L.releasePrimitive(m),b===1/0?null:(e.point?e.point.copy(P):e.point=P.clone(),e.distance=b,e.faceIndex=h,s&&(s.point?s.point.copy(d):s.point=d.clone(),s.point.applyMatrix4(st),P.applyMatrix4(st),s.distance=P.sub(s.point).length(),s.faceIndex=A),e)}closestPointToPoint(t,n={},e=0,s=1/0){const o=e*e,c=s*s;let a=1/0,r=null;if(this.shapecast({boundsTraverseOrder:f=>(pt.copy(t).clamp(f.min,f.max),pt.distanceToSquared(t)),intersectsBounds:(f,p,l)=>l<a&&l<c,intersectsTriangle:(f,p)=>{f.closestPointToPoint(t,pt);const l=t.distanceToSquared(pt);return l<a&&(zt.copy(pt),a=l,r=p),l<o}}),a===1/0)return null;const u=Math.sqrt(a);return n.point?n.point.copy(zt):n.point=zt.clone(),n.distance=u,n.faceIndex=r,n}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(e=>{D(0,new Float32Array(e),fn),t.union(fn)}),t}}const j=new v,G=new v,$=new v,un=new Kt,Ct=new v,Ht=new v,pn=new Kt,dn=new Kt,_t=new K,mn=new K;function dt(i,t){if(!i&&!t)return;const n=i.count===t.count,e=i.normalized===t.normalized,s=i.array.constructor===t.array.constructor,o=i.itemSize===t.itemSize;if(!n||!e||!s||!o)throw new Error}function yt(i,t=null){const n=i.array.constructor,e=i.normalized,s=i.itemSize,o=t===null?i.count:t;return new kt(new n(s*o),s,e)}function An(i,t,n=0){if(i.isInterleavedBufferAttribute){const e=i.itemSize;for(let s=0,o=i.count;s<o;s++){const c=s+n;t.setX(c,i.getX(s)),e>=2&&t.setY(c,i.getY(s)),e>=3&&t.setZ(c,i.getZ(s)),e>=4&&t.setW(c,i.getW(s))}}else{const e=t.array,s=e.constructor,o=e.BYTES_PER_ELEMENT*i.itemSize*n;new s(e.buffer,o,i.array.length).set(i.array)}}function te(i,t,n){const e=i.elements,s=t.elements;for(let o=0,c=s.length;o<c;o++)e[o]+=s[o]*n}function hn(i,t,n){const e=i.skeleton,s=i.geometry,o=e.bones,c=e.boneInverses;pn.fromBufferAttribute(s.attributes.skinIndex,t),dn.fromBufferAttribute(s.attributes.skinWeight,t),_t.elements.fill(0);for(let a=0;a<4;a++){const r=dn.getComponent(a);if(r!==0){const u=pn.getComponent(a);mn.multiplyMatrices(o[u].matrixWorld,c[u]),te(_t,mn,r)}}return _t.multiply(i.bindMatrix).premultiply(i.bindMatrixInverse),n.transformDirection(_t),n}function Yt(i,t,n,e,s){Ct.set(0,0,0);for(let o=0,c=i.length;o<c;o++){const a=t[o],r=i[o];a!==0&&(Ht.fromBufferAttribute(r,e),n?Ct.addScaledVector(Ht,a):Ct.addScaledVector(Ht.sub(s),a))}s.add(Ct)}function ne(i,t={useGroups:!1,updateIndex:!1,skipAttributes:[]},n=new Ft){const e=i[0].index!==null,{useGroups:s=!1,updateIndex:o=!1,skipAttributes:c=[]}=t,a=new Set(Object.keys(i[0].attributes)),r={};let u=0;n.clearGroups();for(let f=0;f<i.length;++f){const p=i[f];let l=0;if(e!==(p.index!==null))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const m in p.attributes){if(!a.has(m))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+m+'" attribute exists among all geometries, or in none of them.');r[m]===void 0&&(r[m]=[]),r[m].push(p.attributes[m]),l++}if(l!==a.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(s){let m;if(e)m=p.index.count;else if(p.attributes.position!==void 0)m=p.attributes.position.count;else throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");n.addGroup(u,m,f),u+=m}}if(e){let f=!1;if(!n.index){let p=0;for(let l=0;l<i.length;++l)p+=i[l].index.count;n.setIndex(new kt(new Uint32Array(p),1,!1)),f=!0}if(o||f){const p=n.index;let l=0,m=0;for(let x=0;x<i.length;++x){const P=i[x],y=P.index;if(c[x]!==!0)for(let d=0;d<y.count;++d)p.setX(l,y.getX(d)+m),l++;m+=P.attributes.position.count}}}for(const f in r){const p=r[f];if(!(f in n.attributes)){let x=0;for(const P in p)x+=p[P].count;n.setAttribute(f,yt(r[f][0],x))}const l=n.attributes[f];let m=0;for(let x=0,P=p.length;x<P;x++){const y=p[x];c[x]!==!0&&An(y,l,m),m+=y.count}}return n}function ee(i,t){if(i===null||t===null)return i===t;if(i.length!==t.length)return!1;for(let n=0,e=i.length;n<e;n++)if(i[n]!==t[n])return!1;return!0}class se{constructor(t){this.matrixWorld=new K,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=t,this.update()}update(){const t=this.mesh,n=t.geometry,e=t.skeleton,s=(n.index?n.index.count:n.attributes.position.count)/3;if(this.matrixWorld.copy(t.matrixWorld),this.geometryHash=n.attributes.position.version,this.primitiveCount=s,e){e.boneTexture||e.computeBoneTexture(),e.update();const o=e.boneMatrices;!this.boneMatrices||this.boneMatrices.length!==o.length?this.boneMatrices=o.slice():this.boneMatrices.set(o)}else this.boneMatrices=null}didChange(){const t=this.mesh,n=t.geometry,e=(n.index?n.index.count:n.attributes.position.count)/3;return!(this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===n.attributes.position.version&&ee(t.skeleton&&t.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===e)}}class re{constructor(t){Array.isArray(t)||(t=[t]);const n=[];t.forEach(e=>{e.traverseVisible(s=>{s.isMesh&&n.push(s)})}),this.meshes=n,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(n.length).fill().map(()=>new Ft),this._diffMap=new WeakMap}getMaterials(){const t=[];return this.meshes.forEach(n=>{Array.isArray(n.material)?t.push(...n.material):t.push(n.material)}),t}generate(t=new Ft){let n=[];const{meshes:e,useGroups:s,_intermediateGeometry:o,_diffMap:c}=this;for(let a=0,r=e.length;a<r;a++){const u=e[a],f=o[a],p=c.get(u);!p||p.didChange(u)?(this._convertToStaticGeometry(u,f),n.push(!1),p?p.update():c.set(u,new se(u))):n.push(!0)}ne(o,{useGroups:s,skipAttributes:n},t);for(const a in t.attributes)t.attributes[a].needsUpdate=!0;return t}_convertToStaticGeometry(t,n=new Ft){const e=t.geometry,s=this.applyWorldTransforms,o=this.attributes.includes("normal"),c=this.attributes.includes("tangent"),a=e.attributes,r=n.attributes;n.index||(n.index=e.index),r.position||n.setAttribute("position",yt(a.position)),o&&!r.normal&&a.normal&&n.setAttribute("normal",yt(a.normal)),c&&!r.tangent&&a.tangent&&n.setAttribute("tangent",yt(a.tangent)),dt(e.index,n.index),dt(a.position,r.position),o&&dt(a.normal,r.normal),c&&dt(a.tangent,r.tangent);const u=a.position,f=o?a.normal:null,p=c?a.tangent:null,l=e.morphAttributes.position,m=e.morphAttributes.normal,x=e.morphAttributes.tangent,P=e.morphTargetsRelative,y=t.morphTargetInfluences,d=new Sn;d.getNormalMatrix(t.matrixWorld);for(let b=0,h=a.position.count;b<h;b++)j.fromBufferAttribute(u,b),f&&G.fromBufferAttribute(f,b),p&&(un.fromBufferAttribute(p,b),$.fromBufferAttribute(p,b)),y&&(l&&Yt(l,y,P,b,j),m&&Yt(m,y,P,b,G),x&&Yt(x,y,P,b,$)),t.isSkinnedMesh&&(t.applyBoneTransform(b,j),f&&hn(t,b,G),p&&hn(t,b,$)),s&&j.applyMatrix4(t.matrixWorld),r.position.setXYZ(b,j.x,j.y,j.z),f&&(s&&G.applyNormalMatrix(d),r.normal.setXYZ(b,G.x,G.y,G.z)),p&&(s&&$.transformDirection(t.matrixWorld),r.tangent.setXYZW(b,$.x,$.y,$.z,un.w));for(const b in this.attributes){const h=this.attributes[b];h==="position"||h==="tangent"||h==="normal"||!(h in a)||(r[h]||n.setAttribute(h,yt(a[h])),dt(a[h],r[h]),An(a[h],r[h]))}return n}}export{Lt as M,oe as R,re as S,D as a};
