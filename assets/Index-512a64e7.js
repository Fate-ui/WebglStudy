var Ze=Object.defineProperty;var Ke=(i,t,e)=>t in i?Ze(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var C=(i,t,e)=>(Ke(i,typeof t!="symbol"?t+"":t,e),e),be=(i,t,e)=>{if(!t.has(i))throw TypeError("Cannot "+e)};var Qt=(i,t,e)=>(be(i,t,"read from private field"),e?e.call(i):t.get(i)),R=(i,t,e)=>{if(t.has(i))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(i):t.set(i,e)};var V=(i,t,e)=>(be(i,t,"access private method"),e);import{O as $e}from"./OrbitControls-79d41aec.js";import{V as B,B as Je,e as Jt,K as ut,a0 as Ee,aT as E,aU as bt,aN as Qe,M as K,o as tn,D as en,y as et,aH as we,d as Vt,aV as nn,a1 as ye,T as sn,aW as on,b as le,f as rn,$ as cn,g as Fe,S as an,P as ln,W as fn,a5 as un,a as pn,E as dn}from"./three.module-4dd0ab4d.js";import{d as mn}from"./index-1a26f821.js";import{u as Ae}from"./index-e976abc4.js";import{G as hn}from"./GLTFLoader-f2abeb44.js";import{R as yn}from"./Reflector-82019ad9.js";import{k as xn,d as bn,s as wn,l as An,p as gn,o as Tn,c as Pn}from"./index-5217155f.js";const dt=new B;function k(i,t,e,n,s,o){const c=2*Math.PI*s/4,a=Math.max(o-2*s,0),r=Math.PI/4;dt.copy(t),dt[n]=0,dt.normalize();const u=.5*c/(c+a),l=1-dt.angleTo(i)/r;return Math.sign(dt[e])===1?l*u:a/(c+a)+u+u*(1-l)}class Sn extends Je{constructor(t=1,e=1,n=1,s=2,o=.1){if(s=s*2+1,o=Math.min(t/2,e/2,n/2,o),super(1,1,1,s,s,s),s===1)return;const c=this.toNonIndexed();this.index=null,this.attributes.position=c.attributes.position,this.attributes.normal=c.attributes.normal,this.attributes.uv=c.attributes.uv;const a=new B,r=new B,u=new B(t,e,n).divideScalar(2).subScalar(o),l=this.attributes.position.array,p=this.attributes.normal.array,f=this.attributes.uv.array,m=l.length/6,x=new B,T=.5/s;for(let y=0,d=0;y<l.length;y+=3,d+=2)switch(a.fromArray(l,y),r.copy(a),r.x-=Math.sign(r.x)*T,r.y-=Math.sign(r.y)*T,r.z-=Math.sign(r.z)*T,r.normalize(),l[y+0]=u.x*Math.sign(a.x)+r.x*o,l[y+1]=u.y*Math.sign(a.y)+r.y*o,l[y+2]=u.z*Math.sign(a.z)+r.z*o,p[y+0]=r.x,p[y+1]=r.y,p[y+2]=r.z,Math.floor(y/m)){case 0:x.set(1,0,0),f[d+0]=k(x,r,"z","y",o,n),f[d+1]=1-k(x,r,"y","z",o,e);break;case 1:x.set(-1,0,0),f[d+0]=1-k(x,r,"z","y",o,n),f[d+1]=1-k(x,r,"y","z",o,e);break;case 2:x.set(0,1,0),f[d+0]=1-k(x,r,"x","z",o,t),f[d+1]=k(x,r,"z","x",o,n);break;case 3:x.set(0,-1,0),f[d+0]=1-k(x,r,"x","z",o,t),f[d+1]=1-k(x,r,"z","x",o,n);break;case 4:x.set(0,0,1),f[d+0]=1-k(x,r,"x","y",o,t),f[d+1]=1-k(x,r,"y","x",o,e);break;case 5:x.set(0,0,-1),f[d+0]=k(x,r,"x","y",o,t),f[d+1]=1-k(x,r,"y","x",o,e);break}}}const Ve=0,vn=1,Bn=2,ge=2,te=1.25,Te=1,Dt=6*4+4+4,fe=65535,Mn=Math.pow(2,-24);class Mt{constructor(){}}function W(i,t,e){return e.min.x=t[i],e.min.y=t[i+1],e.min.z=t[i+2],e.max.x=t[i+3],e.max.y=t[i+4],e.max.z=t[i+5],e}function _n(i){i[0]=i[1]=i[2]=1/0,i[3]=i[4]=i[5]=-1/0}function Pe(i){let t=-1,e=-1/0;for(let n=0;n<3;n++){const s=i[n+3]-i[n];s>e&&(e=s,t=n)}return t}function Se(i,t){t.set(i)}function ve(i,t,e){let n,s;for(let o=0;o<3;o++){const c=o+3;n=i[o],s=t[o],e[o]=n<s?n:s,n=i[c],s=t[c],e[c]=n>s?n:s}}function _t(i,t,e){for(let n=0;n<3;n++){const s=t[i+2*n],o=t[i+2*n+1],c=s-o,a=s+o;c<e[n]&&(e[n]=c),a>e[n+3]&&(e[n+3]=a)}}function mt(i){const t=i[3]-i[0],e=i[4]-i[1],n=i[5]-i[2];return 2*(t*e+e*n+n*t)}function In(i,t){if(!i.index){const e=i.attributes.position.count,n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let s;e>65535?s=new Uint32Array(new n(4*e)):s=new Uint16Array(new n(2*e)),i.setIndex(new Jt(s,1));for(let o=0;o<e;o++)s[o]=o}}function zn(i){if(!i.groups||!i.groups.length)return[{offset:0,count:i.index.count/3}];const t=[],e=new Set;for(const s of i.groups)e.add(s.start),e.add(s.start+s.count);const n=Array.from(e.values()).sort((s,o)=>s-o);for(let s=0;s<n.length-1;s++){const o=n[s],c=n[s+1];t.push({offset:o/3,count:(c-o)/3})}return t}function ee(i,t,e,n,s=null){let o=1/0,c=1/0,a=1/0,r=-1/0,u=-1/0,l=-1/0,p=1/0,f=1/0,m=1/0,x=-1/0,T=-1/0,y=-1/0;const d=s!==null;for(let b=t*6,h=(t+e)*6;b<h;b+=6){const A=i[b+0],w=i[b+1],g=A-w,S=A+w;g<o&&(o=g),S>r&&(r=S),d&&A<p&&(p=A),d&&A>x&&(x=A);const v=i[b+2],P=i[b+3],M=v-P,_=v+P;M<c&&(c=M),_>u&&(u=_),d&&v<f&&(f=v),d&&v>T&&(T=v);const I=i[b+4],z=i[b+5],L=I-z,U=I+z;L<a&&(a=L),U>l&&(l=U),d&&I<m&&(m=I),d&&I>y&&(y=I)}n[0]=o,n[1]=c,n[2]=a,n[3]=r,n[4]=u,n[5]=l,d&&(s[0]=p,s[1]=f,s[2]=m,s[3]=x,s[4]=T,s[5]=y)}function Cn(i,t,e,n){let s=1/0,o=1/0,c=1/0,a=-1/0,r=-1/0,u=-1/0;for(let l=t*6,p=(t+e)*6;l<p;l+=6){const f=i[l+0];f<s&&(s=f),f>a&&(a=f);const m=i[l+2];m<o&&(o=m),m>r&&(r=m);const x=i[l+4];x<c&&(c=x),x>u&&(u=x)}n[0]=s,n[1]=o,n[2]=c,n[3]=a,n[4]=r,n[5]=u}function Ln(i,t,e,n,s){let o=e,c=e+n-1;const a=s.pos,r=s.axis*2;for(;;){for(;o<=c&&t[o*6+r]<a;)o++;for(;o<=c&&t[c*6+r]>=a;)c--;if(o<c){for(let u=0;u<3;u++){let l=i[o*3+u];i[o*3+u]=i[c*3+u],i[c*3+u]=l;let p=t[o*6+u*2+0];t[o*6+u*2+0]=t[c*6+u*2+0],t[c*6+u*2+0]=p;let f=t[o*6+u*2+1];t[o*6+u*2+1]=t[c*6+u*2+1],t[c*6+u*2+1]=f}o++,c--}else return o}}const j=32,Un=(i,t)=>i.candidate-t.candidate,X=new Array(j).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),It=new Float32Array(6);function kn(i,t,e,n,s,o){let c=-1,a=0;if(o===Ve)c=Pe(t),c!==-1&&(a=(t[c]+t[c+3])/2);else if(o===vn)c=Pe(i),c!==-1&&(a=Rn(e,n,s,c));else if(o===Bn){const r=mt(i);let u=te*s;const l=n*6,p=(n+s)*6;for(let f=0;f<3;f++){const m=t[f],y=(t[f+3]-m)/j;if(s<j/4){const d=[...X];d.length=s;let b=0;for(let A=l;A<p;A+=6,b++){const w=d[b];w.candidate=e[A+2*f],w.count=0;const{bounds:g,leftCacheBounds:S,rightCacheBounds:v}=w;for(let P=0;P<3;P++)v[P]=1/0,v[P+3]=-1/0,S[P]=1/0,S[P+3]=-1/0,g[P]=1/0,g[P+3]=-1/0;_t(A,e,g)}d.sort(Un);let h=s;for(let A=0;A<h;A++){const w=d[A];for(;A+1<h&&d[A+1].candidate===w.candidate;)d.splice(A+1,1),h--}for(let A=l;A<p;A+=6){const w=e[A+2*f];for(let g=0;g<h;g++){const S=d[g];w>=S.candidate?_t(A,e,S.rightCacheBounds):(_t(A,e,S.leftCacheBounds),S.count++)}}for(let A=0;A<h;A++){const w=d[A],g=w.count,S=s-w.count,v=w.leftCacheBounds,P=w.rightCacheBounds;let M=0;g!==0&&(M=mt(v)/r);let _=0;S!==0&&(_=mt(P)/r);const I=Te+te*(M*g+_*S);I<u&&(c=f,u=I,a=w.candidate)}}else{for(let h=0;h<j;h++){const A=X[h];A.count=0,A.candidate=m+y+h*y;const w=A.bounds;for(let g=0;g<3;g++)w[g]=1/0,w[g+3]=-1/0}for(let h=l;h<p;h+=6){let g=~~((e[h+2*f]-m)/y);g>=j&&(g=j-1);const S=X[g];S.count++,_t(h,e,S.bounds)}const d=X[j-1];Se(d.bounds,d.rightCacheBounds);for(let h=j-2;h>=0;h--){const A=X[h],w=X[h+1];ve(A.bounds,w.rightCacheBounds,A.rightCacheBounds)}let b=0;for(let h=0;h<j-1;h++){const A=X[h],w=A.count,g=A.bounds,v=X[h+1].rightCacheBounds;w!==0&&(b===0?Se(g,It):ve(g,It,It)),b+=w;let P=0,M=0;b!==0&&(P=mt(It)/r);const _=s-b;_!==0&&(M=mt(v)/r);const I=Te+te*(P*b+M*_);I<u&&(c=f,u=I,a=A.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:c,pos:a}}function Rn(i,t,e,n){let s=0;for(let o=t,c=t+e;o<c;o++)s+=i[o*6+n*2];return s/e}function En(i,t){_n(t);const e=i.attributes.position,n=i.index.array,s=n.length/3,o=new Float32Array(s*6),c=e.normalized,a=e.array,r=e.offset||0;let u=3;e.isInterleavedBufferAttribute&&(u=e.data.stride);const l=["getX","getY","getZ"];for(let p=0;p<s;p++){const f=p*3,m=p*6;let x,T,y;c?(x=n[f+0],T=n[f+1],y=n[f+2]):(x=n[f+0]*u+r,T=n[f+1]*u+r,y=n[f+2]*u+r);for(let d=0;d<3;d++){let b,h,A;c?(b=e[l[d]](x),h=e[l[d]](T),A=e[l[d]](y)):(b=a[x+d],h=a[T+d],A=a[y+d]);let w=b;h<w&&(w=h),A<w&&(w=A);let g=b;h>g&&(g=h),A>g&&(g=A);const S=(g-w)/2,v=d*2;o[m+v+0]=w+S,o[m+v+1]=S+(Math.abs(w)+S)*Mn,w<t[d]&&(t[d]=w),g>t[d+3]&&(t[d+3]=g)}}return o}function Fn(i,t){function e(d){f&&f(d/m)}function n(d,b,h,A=null,w=0){if(!x&&w>=r&&(x=!0,u&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(i))),h<=l||w>=r)return e(b+h),d.offset=b,d.count=h,d;const g=kn(d.boundingData,A,c,b,h,p);if(g.axis===-1)return e(b+h),d.offset=b,d.count=h,d;const S=Ln(a,c,b,h,g);if(S===b||S===b+h)e(b+h),d.offset=b,d.count=h;else{d.splitAxis=g.axis;const v=new Mt,P=b,M=S-b;d.left=v,v.boundingData=new Float32Array(6),ee(c,P,M,v.boundingData,o),n(v,P,M,o,w+1);const _=new Mt,I=S,z=h-M;d.right=_,_.boundingData=new Float32Array(6),ee(c,I,z,_.boundingData,o),n(_,I,z,o,w+1)}return d}In(i,t);const s=new Float32Array(6),o=new Float32Array(6),c=En(i,s),a=i.index.array,r=t.maxDepth,u=t.verbose,l=t.maxLeafTris,p=t.strategy,f=t.onProgress,m=i.index.count/3;let x=!1;const T=[],y=zn(i);if(y.length===1){const d=y[0],b=new Mt;b.boundingData=s,Cn(c,d.offset,d.count,o),n(b,d.offset,d.count,o),T.push(b)}else for(let d of y){const b=new Mt;b.boundingData=new Float32Array(6),ee(c,d.offset,d.count,b.boundingData,o),n(b,d.offset,d.count,o),T.push(b)}return T}function Vn(i,t){const e=Fn(i,t);let n,s,o;const c=[],a=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let l=0;l<e.length;l++){const p=e[l];let f=r(p);const m=new a(Dt*f);n=new Float32Array(m),s=new Uint32Array(m),o=new Uint16Array(m),u(0,p),c.push(m)}return c;function r(l){return l.count?1:1+r(l.left)+r(l.right)}function u(l,p){const f=l/4,m=l/2,x=!!p.count,T=p.boundingData;for(let y=0;y<6;y++)n[f+y]=T[y];if(x){const y=p.offset,d=p.count;return s[f+6]=y,o[m+14]=d,o[m+15]=fe,l+Dt}else{const y=p.left,d=p.right,b=p.splitAxis;let h;if(h=u(l+Dt,y),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return s[f+6]=h/4,h=u(h,d),s[f+7]=b,h}}}class O{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,s=-1/0;for(let o=0,c=t.length;o<c;o++){const r=t[o][e];n=r<n?r:n,s=r>s?r:s}this.min=n,this.max=s}setFromPoints(t,e){let n=1/0,s=-1/0;for(let o=0,c=e.length;o<c;o++){const a=e[o],r=t.dot(a);n=r<n?r:n,s=r>s?r:s}this.min=n,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}O.prototype.setFromBox=function(){const i=new B;return function(e,n){const s=n.min,o=n.max;let c=1/0,a=-1/0;for(let r=0;r<=1;r++)for(let u=0;u<=1;u++)for(let l=0;l<=1;l++){i.x=s.x*r+o.x*(1-r),i.y=s.y*u+o.y*(1-u),i.z=s.z*l+o.z*(1-l);const p=e.dot(i);c=Math.min(p,c),a=Math.max(p,a)}this.min=c,this.max=a}}();const Dn=function(){const i=new B,t=new B,e=new B;return function(s,o,c){const a=s.start,r=i,u=o.start,l=t;e.subVectors(a,u),i.subVectors(s.end,s.start),t.subVectors(o.end,o.start);const p=e.dot(l),f=l.dot(r),m=l.dot(l),x=e.dot(r),y=r.dot(r)*m-f*f;let d,b;y!==0?d=(p*f-x*m)/y:d=0,b=(p+d*f)/m,c.x=d,c.y=b}}(),xe=function(){const i=new ut,t=new B,e=new B;return function(s,o,c,a){Dn(s,o,i);let r=i.x,u=i.y;if(r>=0&&r<=1&&u>=0&&u<=1){s.at(r,c),o.at(u,a);return}else if(r>=0&&r<=1){u<0?o.at(0,a):o.at(1,a),s.closestPointToPoint(a,!0,c);return}else if(u>=0&&u<=1){r<0?s.at(0,c):s.at(1,c),o.closestPointToPoint(c,!0,a);return}else{let l;r<0?l=s.start:l=s.end;let p;u<0?p=o.start:p=o.end;const f=t,m=e;if(s.closestPointToPoint(p,!0,t),o.closestPointToPoint(l,!0,e),f.distanceToSquared(p)<=m.distanceToSquared(l)){c.copy(f),a.copy(p);return}else{c.copy(l),a.copy(m);return}}}}(),Nn=function(){const i=new B,t=new B,e=new Ee,n=new E;return function(o,c){const{radius:a,center:r}=o,{a:u,b:l,c:p}=c;if(n.start=u,n.end=l,n.closestPointToPoint(r,!0,i).distanceTo(r)<=a||(n.start=u,n.end=p,n.closestPointToPoint(r,!0,i).distanceTo(r)<=a)||(n.start=l,n.end=p,n.closestPointToPoint(r,!0,i).distanceTo(r)<=a))return!0;const T=c.getPlane(e);if(Math.abs(T.distanceToPoint(r))<=a){const d=T.projectPoint(r,t);if(c.containsPoint(d))return!0}return!1}}(),Wn=1e-15;function ne(i){return Math.abs(i)<Wn}class H extends bt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new B),this.satBounds=new Array(4).fill().map(()=>new O),this.points=[this.a,this.b,this.c],this.sphere=new Qe,this.plane=new Ee,this.needsUpdate=!0}intersectsSphere(t){return Nn(t,this)}update(){const t=this.a,e=this.b,n=this.c,s=this.points,o=this.satAxes,c=this.satBounds,a=o[0],r=c[0];this.getNormal(a),r.setFromPoints(a,s);const u=o[1],l=c[1];u.subVectors(t,e),l.setFromPoints(u,s);const p=o[2],f=c[2];p.subVectors(e,n),f.setFromPoints(p,s);const m=o[3],x=c[3];m.subVectors(n,t),x.setFromPoints(m,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}H.prototype.closestPointToSegment=function(){const i=new B,t=new B,e=new E;return function(s,o=null,c=null){const{start:a,end:r}=s,u=this.points;let l,p=1/0;for(let f=0;f<3;f++){const m=(f+1)%3;e.start.copy(u[f]),e.end.copy(u[m]),xe(e,s,i,t),l=i.distanceToSquared(t),l<p&&(p=l,o&&o.copy(i),c&&c.copy(t))}return this.closestPointToPoint(a,i),l=a.distanceToSquared(i),l<p&&(p=l,o&&o.copy(i),c&&c.copy(a)),this.closestPointToPoint(r,i),l=r.distanceToSquared(i),l<p&&(p=l,o&&o.copy(i),c&&c.copy(r)),Math.sqrt(p)}}();H.prototype.intersectsTriangle=function(){const i=new H,t=new Array(3),e=new Array(3),n=new O,s=new O,o=new B,c=new B,a=new B,r=new B,u=new B,l=new E,p=new E,f=new E,m=new B;function x(T,y,d){const b=T.points;let h=0,A=-1;for(let w=0;w<3;w++){const{start:g,end:S}=l;g.copy(b[w]),S.copy(b[(w+1)%3]),l.delta(c);const v=ne(y.distanceToPoint(g));if(ne(y.normal.dot(c))&&v){d.copy(l),h=2;break}const P=y.intersectLine(l,m);if(!P&&v&&m.copy(g),(P||v)&&!ne(m.distanceTo(S))){if(h<=1)(h===1?d.start:d.end).copy(m),v&&(A=h);else if(h>=2){(A===1?d.start:d.end).copy(m),h=2;break}if(h++,h===2&&A===-1)break}}return h}return function(y,d=null,b=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(i.copy(y),i.update(),y=i);const h=this.plane,A=y.plane;if(Math.abs(h.normal.dot(A.normal))>1-1e-10){const w=this.satBounds,g=this.satAxes;e[0]=y.a,e[1]=y.b,e[2]=y.c;for(let P=0;P<4;P++){const M=w[P],_=g[P];if(n.setFromPoints(_,e),M.isSeparated(n))return!1}const S=y.satBounds,v=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let P=0;P<4;P++){const M=S[P],_=v[P];if(n.setFromPoints(_,t),M.isSeparated(n))return!1}for(let P=0;P<4;P++){const M=g[P];for(let _=0;_<4;_++){const I=v[_];if(o.crossVectors(M,I),n.setFromPoints(o,t),s.setFromPoints(o,e),n.isSeparated(s))return!1}}return d&&(b||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const w=x(this,A,p);if(w===1&&y.containsPoint(p.end))return d&&(d.start.copy(p.end),d.end.copy(p.end)),!0;if(w!==2)return!1;const g=x(y,h,f);if(g===1&&this.containsPoint(f.end))return d&&(d.start.copy(f.end),d.end.copy(f.end)),!0;if(g!==2)return!1;if(p.delta(a),f.delta(r),a.dot(r)<0){let z=f.start;f.start=f.end,f.end=z}const S=p.start.dot(a),v=p.end.dot(a),P=f.start.dot(a),M=f.end.dot(a),_=v<P,I=S<M;return S!==M&&P!==v&&_===I?!1:(d&&(u.subVectors(p.start,f.start),u.dot(a)>0?d.start.copy(p.start):d.start.copy(f.start),u.subVectors(p.end,f.end),u.dot(a)<0?d.end.copy(p.end):d.end.copy(f.end)),!0)}}}();H.prototype.distanceToPoint=function(){const i=new B;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}}();H.prototype.distanceToTriangle=function(){const i=new B,t=new B,e=["a","b","c"],n=new E,s=new E;return function(c,a=null,r=null){const u=a||r?n:null;if(this.intersectsTriangle(c,u))return(a||r)&&(a&&u.getCenter(a),r&&u.getCenter(r)),0;let l=1/0;for(let p=0;p<3;p++){let f;const m=e[p],x=c[m];this.closestPointToPoint(x,i),f=x.distanceToSquared(i),f<l&&(l=f,a&&a.copy(i),r&&r.copy(x));const T=this[m];c.closestPointToPoint(T,i),f=T.distanceToSquared(i),f<l&&(l=f,a&&a.copy(T),r&&r.copy(i))}for(let p=0;p<3;p++){const f=e[p],m=e[(p+1)%3];n.set(this[f],this[m]);for(let x=0;x<3;x++){const T=e[x],y=e[(x+1)%3];s.set(c[T],c[y]),xe(n,s,i,t);const d=i.distanceToSquared(t);d<l&&(l=d,a&&a.copy(i),r&&r.copy(t))}}return Math.sqrt(l)}}();class q{constructor(t,e,n){this.isOrientedBox=!0,this.min=new B,this.max=new B,this.matrix=new K,this.invMatrix=new K,this.points=new Array(8).fill().map(()=>new B),this.satAxes=new Array(3).fill().map(()=>new B),this.satBounds=new Array(3).fill().map(()=>new O),this.alignedSatBounds=new Array(3).fill().map(()=>new O),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const t=this.matrix,e=this.min,n=this.max,s=this.points;for(let u=0;u<=1;u++)for(let l=0;l<=1;l++)for(let p=0;p<=1;p++){const f=1*u|2*l|4*p,m=s[f];m.x=u?n.x:e.x,m.y=l?n.y:e.y,m.z=p?n.z:e.z,m.applyMatrix4(t)}const o=this.satBounds,c=this.satAxes,a=s[0];for(let u=0;u<3;u++){const l=c[u],p=o[u],f=1<<u,m=s[f];l.subVectors(a,m),p.setFromPoints(l,s)}const r=this.alignedSatBounds;r[0].setFromPointsField(s,"x"),r[1].setFromPointsField(s,"y"),r[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const i=new O;return function(e){this.needsUpdate&&this.update();const n=e.min,s=e.max,o=this.satBounds,c=this.satAxes,a=this.alignedSatBounds;if(i.min=n.x,i.max=s.x,a[0].isSeparated(i)||(i.min=n.y,i.max=s.y,a[1].isSeparated(i))||(i.min=n.z,i.max=s.z,a[2].isSeparated(i)))return!1;for(let r=0;r<3;r++){const u=c[r],l=o[r];if(i.setFromBox(u,e),l.isSeparated(i))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const i=new H,t=new Array(3),e=new O,n=new O,s=new B;return function(c){this.needsUpdate&&this.update(),c.isExtendedTriangle?c.needsUpdate&&c.update():(i.copy(c),i.update(),c=i);const a=this.satBounds,r=this.satAxes;t[0]=c.a,t[1]=c.b,t[2]=c.c;for(let f=0;f<3;f++){const m=a[f],x=r[f];if(e.setFromPoints(x,t),m.isSeparated(e))return!1}const u=c.satBounds,l=c.satAxes,p=this.points;for(let f=0;f<3;f++){const m=u[f],x=l[f];if(e.setFromPoints(x,p),m.isSeparated(e))return!1}for(let f=0;f<3;f++){const m=r[f];for(let x=0;x<4;x++){const T=l[x];if(s.crossVectors(m,T),e.setFromPoints(s,t),n.setFromPoints(s,p),e.isSeparated(n))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();q.prototype.distanceToPoint=function(){const i=new B;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}}();q.prototype.distanceToBox=function(){const i=["x","y","z"],t=new Array(12).fill().map(()=>new E),e=new Array(12).fill().map(()=>new E),n=new B,s=new B;return function(c,a=0,r=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(c))return(r||u)&&(c.getCenter(s),this.closestPointToPoint(s,n),c.closestPointToPoint(n,s),r&&r.copy(n),u&&u.copy(s)),0;const l=a*a,p=c.min,f=c.max,m=this.points;let x=1/0;for(let y=0;y<8;y++){const d=m[y];s.copy(d).clamp(p,f);const b=d.distanceToSquared(s);if(b<x&&(x=b,r&&r.copy(d),u&&u.copy(s),b<l))return Math.sqrt(b)}let T=0;for(let y=0;y<3;y++)for(let d=0;d<=1;d++)for(let b=0;b<=1;b++){const h=(y+1)%3,A=(y+2)%3,w=d<<h|b<<A,g=1<<y|d<<h|b<<A,S=m[w],v=m[g];t[T].set(S,v);const M=i[y],_=i[h],I=i[A],z=e[T],L=z.start,U=z.end;L[M]=p[M],L[_]=d?p[_]:f[_],L[I]=b?p[I]:f[_],U[M]=f[M],U[_]=d?p[_]:f[_],U[I]=b?p[I]:f[_],T++}for(let y=0;y<=1;y++)for(let d=0;d<=1;d++)for(let b=0;b<=1;b++){s.x=y?f.x:p.x,s.y=d?f.y:p.y,s.z=b?f.z:p.z,this.closestPointToPoint(s,n);const h=s.distanceToSquared(n);if(h<x&&(x=h,r&&r.copy(n),u&&u.copy(s),h<l))return Math.sqrt(h)}for(let y=0;y<12;y++){const d=t[y];for(let b=0;b<12;b++){const h=e[b];xe(d,h,n,s);const A=n.distanceToSquared(s);if(A<x&&(x=A,r&&r.copy(n),u&&u.copy(s),A<l))return Math.sqrt(A)}}return Math.sqrt(x)}}();const it=new B,ot=new B,rt=new B,zt=new ut,Ct=new ut,Lt=new ut,Be=new B,Me=new B,_e=new B,Ut=new B;function qn(i,t,e,n,s,o){let c;return o===tn?c=i.intersectTriangle(n,e,t,!0,s):c=i.intersectTriangle(t,e,n,o!==en,s),c===null?null:{distance:i.origin.distanceTo(s),point:s.clone()}}function jn(i,t,e,n,s,o,c,a,r){it.fromBufferAttribute(t,o),ot.fromBufferAttribute(t,c),rt.fromBufferAttribute(t,a);const u=qn(i,it,ot,rt,Ut,r);if(u){n&&(zt.fromBufferAttribute(n,o),Ct.fromBufferAttribute(n,c),Lt.fromBufferAttribute(n,a),u.uv=bt.getInterpolation(Ut,it,ot,rt,zt,Ct,Lt,new ut)),s&&(zt.fromBufferAttribute(s,o),Ct.fromBufferAttribute(s,c),Lt.fromBufferAttribute(s,a),u.uv1=bt.getInterpolation(Ut,it,ot,rt,zt,Ct,Lt,new ut)),e&&(Be.fromBufferAttribute(e,o),Me.fromBufferAttribute(e,c),_e.fromBufferAttribute(e,a),u.normal=bt.getInterpolation(Ut,it,ot,rt,Be,Me,_e,new B),u.normal.dot(i.direction)>0&&u.normal.multiplyScalar(-1));const l={a:o,b:c,c:a,normal:new B,materialIndex:0};bt.getNormal(it,ot,rt,l.normal),u.face=l,u.faceIndex=o}return u}function De(i,t,e,n,s){const o=n*3,c=i.index.getX(o),a=i.index.getX(o+1),r=i.index.getX(o+2),{position:u,normal:l,uv:p,uv1:f}=i.attributes,m=jn(e,u,l,p,f,c,a,r,t);return m?(m.faceIndex=n,s&&s.push(m),m):null}function On(i,t,e,n,s,o){for(let c=n,a=n+s;c<a;c++)De(i,t,e,c,o)}function Hn(i,t,e,n,s){let o=1/0,c=null;for(let a=n,r=n+s;a<r;a++){const u=De(i,t,e,a);u&&u.distance<o&&(c=u,o=u.distance)}return c}function N(i,t,e,n){const s=i.a,o=i.b,c=i.c;let a=t,r=t+1,u=t+2;e&&(a=e.getX(t),r=e.getX(t+1),u=e.getX(t+2)),s.x=n.getX(a),s.y=n.getY(a),s.z=n.getZ(a),o.x=n.getX(r),o.y=n.getY(r),o.z=n.getZ(r),c.x=n.getX(u),c.y=n.getY(u),c.z=n.getZ(u)}function Ie(i,t,e,n,s,o,c){const a=e.index,r=e.attributes.position;for(let u=i,l=t+i;u<l;u++)if(N(c,u*3,a,r),c.needsUpdate=!0,n(c,u,s,o))return!0;return!1}class Ne{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function G(i,t){return t[i+15]===65535}function ft(i,t){return t[i+6]}function Tt(i,t){return t[i+14]}function Pt(i){return i+8}function St(i,t){return t[i+6]}function Xn(i,t){return t[i+7]}const at=new et,Wt=new B,Gn=["x","y","z"];function ue(i,t,e,n,s){let o=i*2,c=pt,a=Y,r=Z;if(G(o,a)){const l=ft(i,r),p=Tt(o,a);On(t,e,n,l,p,s)}else{const l=Pt(i);qt(l,c,n,Wt)&&ue(l,t,e,n,s);const p=St(i,r);qt(p,c,n,Wt)&&ue(p,t,e,n,s)}}function pe(i,t,e,n){let s=i*2,o=pt,c=Y,a=Z;if(G(s,c)){const u=ft(i,a),l=Tt(s,c);return Hn(t,e,n,u,l)}else{const u=Xn(i,a),l=Gn[u],f=n.direction[l]>=0;let m,x;f?(m=Pt(i),x=St(i,a)):(m=St(i,a),x=Pt(i));const y=qt(m,o,n,Wt)?pe(m,t,e,n):null;if(y){const h=y.point[l];if(f?h<=o[x+u]:h>=o[x+u+3])return y}const b=qt(x,o,n,Wt)?pe(x,t,e,n):null;return y&&b?y.distance<=b.distance?y:b:y||b||null}}const Yn=function(){let i,t;const e=[],n=new Ne(()=>new et);return function(...c){i=n.getPrimitive(),t=n.getPrimitive(),e.push(i,t);const a=s(...c);n.releasePrimitive(i),n.releasePrimitive(t),e.pop(),e.pop();const r=e.length;return r>0&&(t=e[r-1],i=e[r-2]),a};function s(o,c,a,r,u=null,l=0,p=0){function f(h){let A=h*2,w=Y,g=Z;for(;!G(A,w);)h=Pt(h),A=h*2;return ft(h,g)}function m(h){let A=h*2,w=Y,g=Z;for(;!G(A,w);)h=St(h,g),A=h*2;return ft(h,g)+Tt(A,w)}let x=o*2,T=pt,y=Y,d=Z;if(G(x,y)){const h=ft(o,d),A=Tt(x,y);return W(o,T,i),r(h,A,!1,p,l+o,i)}else{const h=Pt(o),A=St(o,d);let w=h,g=A,S,v,P,M;if(u&&(P=i,M=t,W(w,T,P),W(g,T,M),S=u(P),v=u(M),v<S)){w=A,g=h;const F=S;S=v,v=F,P=M}P||(P=i,W(w,T,P));const _=G(w*2,y),I=a(P,_,S,p+1,l+w);let z;if(I===ge){const F=f(w),st=m(w)-F;z=r(F,st,!0,p+1,l+w,P)}else z=I&&s(w,c,a,r,u,l,p+1);if(z)return!0;M=t,W(g,T,M);const L=G(g*2,y),U=a(M,L,v,p+1,l+g);let nt;if(U===ge){const F=f(g),st=m(g)-F;nt=r(F,st,!0,p+1,l+g,M)}else nt=U&&s(g,c,a,r,u,l,p+1);return!!nt}}}(),Zn=function(){const i=new H,t=new H,e=new K,n=new q,s=new q;return function o(c,a,r,u,l=null){let p=c*2,f=pt,m=Y,x=Z;if(l===null&&(r.boundingBox||r.computeBoundingBox(),n.set(r.boundingBox.min,r.boundingBox.max,u),l=n),G(p,m)){const y=a,d=y.index,b=y.attributes.position,h=r.index,A=r.attributes.position,w=ft(c,x),g=Tt(p,m);if(e.copy(u).invert(),r.boundsTree)return W(c,f,s),s.matrix.copy(e),s.needsUpdate=!0,r.boundsTree.shapecast({intersectsBounds:v=>s.intersectsBox(v),intersectsTriangle:v=>{v.a.applyMatrix4(u),v.b.applyMatrix4(u),v.c.applyMatrix4(u),v.needsUpdate=!0;for(let P=w*3,M=(g+w)*3;P<M;P+=3)if(N(t,P,d,b),t.needsUpdate=!0,v.intersectsTriangle(t))return!0;return!1}});for(let S=w*3,v=g+w*3;S<v;S+=3){N(i,S,d,b),i.a.applyMatrix4(e),i.b.applyMatrix4(e),i.c.applyMatrix4(e),i.needsUpdate=!0;for(let P=0,M=h.count;P<M;P+=3)if(N(t,P,h,A),t.needsUpdate=!0,i.intersectsTriangle(t))return!0}}else{const y=c+8,d=x[c+6];return W(y,f,at),!!(l.intersectsBox(at)&&o(y,a,r,u,l)||(W(d,f,at),l.intersectsBox(at)&&o(d,a,r,u,l)))}}}();function qt(i,t,e,n){return W(i,t,at),e.intersectBox(at,n)}const de=[];let Nt,pt,Y,Z;function wt(i){Nt&&de.push(Nt),Nt=i,pt=new Float32Array(i),Y=new Uint16Array(i),Z=new Uint32Array(i)}function kt(){Nt=null,pt=null,Y=null,Z=null,de.length&&wt(de.pop())}const se=Symbol("skip tree generation"),ie=new et,oe=new et,ct=new K,$=new q,ht=new q,yt=new B,Rt=new B,Kn=new B,$n=new B,Jn=new B,ze=new et,D=new Ne(()=>new H);class gt{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),gt.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,s=t._roots,o=n.getIndex();let c;return e.cloneBuffers?c={roots:s.map(a=>a.slice()),index:o.array.slice()}:c={roots:s,index:o.array},c}static deserialize(t,e,n={}){if(typeof n=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),gt.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});n={setIndex:!0,...n};const{index:s,roots:o}=t,c=new gt(e,{...n,[se]:!0});if(c._roots=o,n.setIndex){const a=e.getIndex();if(a===null){const r=new Jt(t.index,1,!1);e.setIndex(r)}else a.array!==s&&(a.array.set(s),a.needsUpdate=!0)}return c}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:Ve,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[se]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[se]||(this._roots=Vn(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new et))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,s=e.attributes.position;let o,c,a,r,u=0;const l=this._roots;for(let f=0,m=l.length;f<m;f++)o=l[f],c=new Uint32Array(o),a=new Uint16Array(o),r=new Float32Array(o),p(0,u),u+=o.byteLength;function p(f,m,x=!1){const T=f*2;if(a[T+15]===fe){const d=c[f+6],b=a[T+14];let h=1/0,A=1/0,w=1/0,g=-1/0,S=-1/0,v=-1/0;for(let P=3*d,M=3*(d+b);P<M;P++){const _=n[P],I=s.getX(_),z=s.getY(_),L=s.getZ(_);I<h&&(h=I),I>g&&(g=I),z<A&&(A=z),z>S&&(S=z),L<w&&(w=L),L>v&&(v=L)}return r[f+0]!==h||r[f+1]!==A||r[f+2]!==w||r[f+3]!==g||r[f+4]!==S||r[f+5]!==v?(r[f+0]=h,r[f+1]=A,r[f+2]=w,r[f+3]=g,r[f+4]=S,r[f+5]=v,!0):!1}else{const d=f+8,b=c[f+6],h=d+m,A=b+m;let w=x,g=!1,S=!1;t?w||(g=t.has(h),S=t.has(A),w=!g&&!S):(g=!0,S=!0);const v=w||g,P=w||S;let M=!1;v&&(M=p(d,m,w));let _=!1;P&&(_=p(b,m,w));const I=M||_;if(I)for(let z=0;z<3;z++){const L=d+z,U=b+z,nt=r[L],F=r[L+3],Bt=r[U],st=r[U+3];r[f+z]=nt<Bt?nt:Bt,r[f+z+3]=F>st?F:st}return I}}}traverse(t,e=0){const n=this._roots[e],s=new Uint32Array(n),o=new Uint16Array(n);c(0);function c(a,r=0){const u=a*2,l=o[u+15]===fe;if(l){const p=s[a+6],f=o[u+14];t(r,l,new Float32Array(n,a*4,6),p,f)}else{const p=a+Dt/4,f=s[a+6],m=s[a+7];t(r,l,new Float32Array(n,a*4,6),m)||(c(p,r+1),c(f,r+1))}}}raycast(t,e=we){const n=this._roots,s=this.geometry,o=[],c=e.isMaterial,a=Array.isArray(e),r=s.groups,u=c?e.side:e;for(let l=0,p=n.length;l<p;l++){const f=a?e[r[l].materialIndex].side:u,m=o.length;if(wt(n[l]),ue(0,s,f,t,o),kt(),a){const x=r[l].materialIndex;for(let T=m,y=o.length;T<y;T++)o[T].face.materialIndex=x}}return o}raycastFirst(t,e=we){const n=this._roots,s=this.geometry,o=e.isMaterial,c=Array.isArray(e);let a=null;const r=s.groups,u=o?e.side:e;for(let l=0,p=n.length;l<p;l++){const f=c?e[r[l].materialIndex].side:u;wt(n[l]);const m=pe(0,s,f,t);kt(),m!=null&&(a==null||m.distance<a.distance)&&(a=m,c&&(m.face.materialIndex=r[l].materialIndex))}return a}intersectsGeometry(t,e){const n=this.geometry;let s=!1;for(const o of this._roots)if(wt(o),s=Zn(0,n,t,e),kt(),s)break;return s}shapecast(t,e,n){const s=this.geometry;if(t instanceof Function){if(e){const f=e;e=(m,x,T,y)=>{const d=x*3;return f(m,d,d+1,d+2,T,y)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=D.getPrimitive();let{boundsTraverseOrder:c,intersectsBounds:a,intersectsRange:r,intersectsTriangle:u}=t;if(r&&u){const f=r;r=(m,x,T,y,d)=>f(m,x,T,y,d)?!0:Ie(m,x,s,u,T,y,o)}else r||(u?r=(f,m,x,T)=>Ie(f,m,s,u,x,T,o):r=(f,m,x)=>x);let l=!1,p=0;for(const f of this._roots){if(wt(f),l=Yn(0,s,a,r,c,p),kt(),l)break;p+=f.byteLength}return D.releasePrimitive(o),l}bvhcast(t,e,n){let{intersectsRanges:s,intersectsTriangles:o}=n;const c=this.geometry.index,a=this.geometry.attributes.position,r=t.geometry.index,u=t.geometry.attributes.position;ct.copy(e).invert();const l=D.getPrimitive(),p=D.getPrimitive();if(o){let m=function(x,T,y,d,b,h,A,w){for(let g=y,S=y+d;g<S;g++){N(p,g*3,r,u),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let v=x,P=x+T;v<P;v++)if(N(l,v*3,c,a),l.needsUpdate=!0,o(l,p,v,g,b,h,A,w))return!0}return!1};if(s){const x=s;s=function(T,y,d,b,h,A,w,g){return x(T,y,d,b,h,A,w,g)?!0:m(T,y,d,b,h,A,w,g)}}else s=m}t.getBoundingBox(oe),oe.applyMatrix4(e);const f=this.shapecast({intersectsBounds:m=>oe.intersectsBox(m),intersectsRange:(m,x,T,y,d,b)=>(ie.copy(b),ie.applyMatrix4(ct),t.shapecast({intersectsBounds:h=>ie.intersectsBox(h),intersectsRange:(h,A,w,g,S)=>s(m,x,h,A,y,d,g,S)}))});return D.releasePrimitive(l),D.releasePrimitive(p),f}intersectsBox(t,e){return $.set(t.min,t.max,e),$.needsUpdate=!0,this.shapecast({intersectsBounds:n=>$.intersectsBox(n),intersectsTriangle:n=>$.intersectsTriangle(n)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},s={},o=0,c=1/0){t.boundingBox||t.computeBoundingBox(),$.set(t.boundingBox.min,t.boundingBox.max,e),$.needsUpdate=!0;const a=this.geometry,r=a.attributes.position,u=a.index,l=t.attributes.position,p=t.index,f=D.getPrimitive(),m=D.getPrimitive();let x=Rt,T=Kn,y=null,d=null;s&&(y=$n,d=Jn);let b=1/0,h=null,A=null;return ct.copy(e).invert(),ht.matrix.copy(ct),this.shapecast({boundsTraverseOrder:w=>$.distanceToBox(w),intersectsBounds:(w,g,S)=>S<b&&S<c?(g&&(ht.min.copy(w.min),ht.max.copy(w.max),ht.needsUpdate=!0),!0):!1,intersectsRange:(w,g)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:S=>ht.distanceToBox(S),intersectsBounds:(S,v,P)=>P<b&&P<c,intersectsRange:(S,v)=>{for(let P=S*3,M=(S+v)*3;P<M;P+=3){N(m,P,p,l),m.a.applyMatrix4(e),m.b.applyMatrix4(e),m.c.applyMatrix4(e),m.needsUpdate=!0;for(let _=w*3,I=(w+g)*3;_<I;_+=3){N(f,_,u,r),f.needsUpdate=!0;const z=f.distanceToTriangle(m,x,y);if(z<b&&(T.copy(x),d&&d.copy(y),b=z,h=_/3,A=P/3),z<o)return!0}}}});{const S=p?p.count:l.count;for(let v=0,P=S;v<P;v+=3){N(m,v,p,l),m.a.applyMatrix4(e),m.b.applyMatrix4(e),m.c.applyMatrix4(e),m.needsUpdate=!0;for(let M=w*3,_=(w+g)*3;M<_;M+=3){N(f,M,u,r),f.needsUpdate=!0;const I=f.distanceToTriangle(m,x,y);if(I<b&&(T.copy(x),d&&d.copy(y),b=I,h=M/3,A=v/3),I<o)return!0}}}}}),D.releasePrimitive(f),D.releasePrimitive(m),b===1/0?null:(n.point?n.point.copy(T):n.point=T.clone(),n.distance=b,n.faceIndex=h,s&&(s.point?s.point.copy(d):s.point=d.clone(),s.point.applyMatrix4(ct),T.applyMatrix4(ct),s.distance=T.sub(s.point).length(),s.faceIndex=A),n)}closestPointToPoint(t,e={},n=0,s=1/0){const o=n*n,c=s*s;let a=1/0,r=null;if(this.shapecast({boundsTraverseOrder:l=>(yt.copy(t).clamp(l.min,l.max),yt.distanceToSquared(t)),intersectsBounds:(l,p,f)=>f<a&&f<c,intersectsTriangle:(l,p)=>{l.closestPointToPoint(t,yt);const f=t.distanceToSquared(yt);return f<a&&(Rt.copy(yt),a=f,r=p),f<o}}),a===1/0)return null;const u=Math.sqrt(a);return e.point?e.point.copy(Rt):e.point=Rt.clone(),e.distance=u,e.faceIndex=r,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(n=>{W(0,new Float32Array(n),ze),t.union(ze)}),t}}const J=new B,Q=new B,tt=new B,Ce=new ye,Et=new B,re=new B,Le=new ye,Ue=new ye,Ft=new K,ke=new K;function xt(i,t){if(!i&&!t)return;const e=i.count===t.count,n=i.normalized===t.normalized,s=i.array.constructor===t.array.constructor,o=i.itemSize===t.itemSize;if(!e||!n||!s||!o)throw new Error}function At(i,t=null){const e=i.array.constructor,n=i.normalized,s=i.itemSize,o=t===null?i.count:t;return new Jt(new e(s*o),s,n)}function We(i,t,e=0){if(i.isInterleavedBufferAttribute){const n=i.itemSize;for(let s=0,o=i.count;s<o;s++){const c=s+e;t.setX(c,i.getX(s)),n>=2&&t.setY(c,i.getY(s)),n>=3&&t.setZ(c,i.getZ(s)),n>=4&&t.setW(c,i.getW(s))}}else{const n=t.array,s=n.constructor,o=n.BYTES_PER_ELEMENT*i.itemSize*e;new s(n.buffer,o,i.array.length).set(i.array)}}function Qn(i,t,e){const n=i.elements,s=t.elements;for(let o=0,c=s.length;o<c;o++)n[o]+=s[o]*e}function Re(i,t,e){const n=i.skeleton,s=i.geometry,o=n.bones,c=n.boneInverses;Le.fromBufferAttribute(s.attributes.skinIndex,t),Ue.fromBufferAttribute(s.attributes.skinWeight,t),Ft.elements.fill(0);for(let a=0;a<4;a++){const r=Ue.getComponent(a);if(r!==0){const u=Le.getComponent(a);ke.multiplyMatrices(o[u].matrixWorld,c[u]),Qn(Ft,ke,r)}}return Ft.multiply(i.bindMatrix).premultiply(i.bindMatrixInverse),e.transformDirection(Ft),e}function ce(i,t,e,n,s){Et.set(0,0,0);for(let o=0,c=i.length;o<c;o++){const a=t[o],r=i[o];a!==0&&(re.fromBufferAttribute(r,n),e?Et.addScaledVector(re,a):Et.addScaledVector(re.sub(s),a))}s.add(Et)}function ts(i,t={useGroups:!1,updateIndex:!1,skipAttributes:[]},e=new Vt){const n=i[0].index!==null,{useGroups:s=!1,updateIndex:o=!1,skipAttributes:c=[]}=t,a=new Set(Object.keys(i[0].attributes)),r={};let u=0;e.clearGroups();for(let l=0;l<i.length;++l){const p=i[l];let f=0;if(n!==(p.index!==null))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const m in p.attributes){if(!a.has(m))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+m+'" attribute exists among all geometries, or in none of them.');r[m]===void 0&&(r[m]=[]),r[m].push(p.attributes[m]),f++}if(f!==a.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(s){let m;if(n)m=p.index.count;else if(p.attributes.position!==void 0)m=p.attributes.position.count;else throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");e.addGroup(u,m,l),u+=m}}if(n){let l=!1;if(!e.index){let p=0;for(let f=0;f<i.length;++f)p+=i[f].index.count;e.setIndex(new Jt(new Uint32Array(p),1,!1)),l=!0}if(o||l){const p=e.index;let f=0,m=0;for(let x=0;x<i.length;++x){const T=i[x],y=T.index;if(c[x]!==!0)for(let d=0;d<y.count;++d)p.setX(f,y.getX(d)+m),f++;m+=T.attributes.position.count}}}for(const l in r){const p=r[l];if(!(l in e.attributes)){let x=0;for(const T in p)x+=p[T].count;e.setAttribute(l,At(r[l][0],x))}const f=e.attributes[l];let m=0;for(let x=0,T=p.length;x<T;x++){const y=p[x];c[x]!==!0&&We(y,f,m),m+=y.count}}return e}function es(i,t){if(i===null||t===null)return i===t;if(i.length!==t.length)return!1;for(let e=0,n=i.length;e<n;e++)if(i[e]!==t[e])return!1;return!0}class ns{constructor(t){this.matrixWorld=new K,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=t,this.update()}update(){const t=this.mesh,e=t.geometry,n=t.skeleton,s=(e.index?e.index.count:e.attributes.position.count)/3;if(this.matrixWorld.copy(t.matrixWorld),this.geometryHash=e.attributes.position.version,this.primitiveCount=s,n){n.boneTexture||n.computeBoneTexture(),n.update();const o=n.boneMatrices;!this.boneMatrices||this.boneMatrices.length!==o.length?this.boneMatrices=o.slice():this.boneMatrices.set(o)}else this.boneMatrices=null}didChange(){const t=this.mesh,e=t.geometry,n=(e.index?e.index.count:e.attributes.position.count)/3;return!(this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===e.attributes.position.version&&es(t.skeleton&&t.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===n)}}class ss{constructor(t){Array.isArray(t)||(t=[t]);const e=[];t.forEach(n=>{n.traverseVisible(s=>{s.isMesh&&e.push(s)})}),this.meshes=e,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(e.length).fill().map(()=>new Vt),this._diffMap=new WeakMap}getMaterials(){const t=[];return this.meshes.forEach(e=>{Array.isArray(e.material)?t.push(...e.material):t.push(e.material)}),t}generate(t=new Vt){let e=[];const{meshes:n,useGroups:s,_intermediateGeometry:o,_diffMap:c}=this;for(let a=0,r=n.length;a<r;a++){const u=n[a],l=o[a],p=c.get(u);!p||p.didChange(u)?(this._convertToStaticGeometry(u,l),e.push(!1),p?p.update():c.set(u,new ns(u))):e.push(!0)}ts(o,{useGroups:s,skipAttributes:e},t);for(const a in t.attributes)t.attributes[a].needsUpdate=!0;return t}_convertToStaticGeometry(t,e=new Vt){const n=t.geometry,s=this.applyWorldTransforms,o=this.attributes.includes("normal"),c=this.attributes.includes("tangent"),a=n.attributes,r=e.attributes;e.index||(e.index=n.index),r.position||e.setAttribute("position",At(a.position)),o&&!r.normal&&a.normal&&e.setAttribute("normal",At(a.normal)),c&&!r.tangent&&a.tangent&&e.setAttribute("tangent",At(a.tangent)),xt(n.index,e.index),xt(a.position,r.position),o&&xt(a.normal,r.normal),c&&xt(a.tangent,r.tangent);const u=a.position,l=o?a.normal:null,p=c?a.tangent:null,f=n.morphAttributes.position,m=n.morphAttributes.normal,x=n.morphAttributes.tangent,T=n.morphTargetsRelative,y=t.morphTargetInfluences,d=new nn;d.getNormalMatrix(t.matrixWorld);for(let b=0,h=a.position.count;b<h;b++)J.fromBufferAttribute(u,b),l&&Q.fromBufferAttribute(l,b),p&&(Ce.fromBufferAttribute(p,b),tt.fromBufferAttribute(p,b)),y&&(f&&ce(f,y,T,b,J),m&&ce(m,y,T,b,Q),x&&ce(x,y,T,b,tt)),t.isSkinnedMesh&&(t.applyBoneTransform(b,J),l&&Re(t,b,Q),p&&Re(t,b,tt)),s&&J.applyMatrix4(t.matrixWorld),r.position.setXYZ(b,J.x,J.y,J.z),l&&(s&&Q.applyNormalMatrix(d),r.normal.setXYZ(b,Q.x,Q.y,Q.z)),p&&(s&&tt.transformDirection(t.matrixWorld),r.tangent.setXYZW(b,tt.x,tt.y,tt.z,Ce.w));for(const b in this.attributes){const h=this.attributes[b];h==="position"||h==="tangent"||h==="normal"||!(h in a)||(r[h]||e.setAttribute(h,At(a[h])),xt(a[h],r[h]),We(a[h],r[h]))}return e}}const is=[new URL("/assets/1-91d1fd28.png",self.location).href,new URL("/assets/2-577e2981.png",self.location).href,new URL("/assets/3-e96f4416.jpg",self.location).href,new URL("/assets/4-2c59a331.jpg",self.location).href,new URL("/assets/5-c8aed110.png",self.location).href,new URL("/assets/6-9d09d2dc.png",self.location).href,new URL("/assets/7-68ca4bc6.png",self.location).href,new URL("/assets/8-74f5f15e.jpg",self.location).href,new URL("/assets/9-44142f78.jpg",self.location).href,new URL("/assets/10-1cde4a43.png",self.location).href],ae={1:{title:"《小橘贝》",author:"小雅",describe:`
		它站在画面中央，静静地凝视着观众，柔和的橘色将它的柔软毛发和灵动眼眸妩媚地勾勒出来。<br>
		小猫的小耳朵微微竖起，似乎在倾听着什么，身体略微前倾，展现出它对周围世界的好奇和敏感。<br>
		画面的背景色以淡蓝色为主，这种色彩营造了温馨轻柔的氛围，让人仿佛置身于阳光明媚的午后时光中。<br>
		整个画作细致精致、色彩明亮而温暖，带给人们一种温馨、亲切的感受。
		`},2:{title:"《微光》",author:"小雅",describe:`
		微小的星光和银河组成了一个神秘的宇宙世界，让人感到无限的遐想和想象。<br>
		当你凝视着这幅画时，你会感受到无边无际的深邃和宁静。<br>
		你仿佛置身于一个没有噪音、没有烦扰的夜空中。在这个宁静的空间里，你可以看到银河中微光闪烁的样子。<br>
		这些微光似乎是夜空中唯一的生命体，它们微弱却坚定地发出光芒，点亮着整个银河系。<br>
		这些微光是如此的纤细而又强大，仿佛在无边的黑暗中，只有它们才能给人带来希望和力量。
		`},3:{title:"《天鹅》",author:"小雅",describe:`
		湖面静谧如镜，微风拂过，泛起一圈圈细微的涟漪，仿佛为优雅的白色天鹅们铺上了一层晶莹剔透的纱帐。<br>
		其中一只白羽如雪的天鹅在水中自由自在地舞动着优美的姿态，如同一位华丽的舞者在水上翩翩起舞。<br>
		纯白色羽毛在阳光的照射下，闪烁着淡淡的光晕，如同珍珠一般璀璨夺目。
		`},4:{title:"《山中小屋》",author:"小雅",describe:`
		宁静而恬淡，远山隐现于云雾中，仿佛是一幅梦幻般的画卷。<br>
		小屋在山脚下宁静地伫立，墙体洁白，屋顶泛着淡淡的阳光，使得小屋与周围的环境相互映衬。<br>
		流露出一种自然的和谐之美。
		`},5:{title:"《太空人》",author:"小雅",describe:`
		太空人身披着黑夜在星罗棋布的宇宙中漫游。<br>
		虽说现在已经是太空时代，人类早就可以坐太空飞船去月球，<br>
		但却永远无法探索别人内心的宇宙。
		`},6:{title:"《粉色海洋》",author:"小雅",describe:`
		粉色云朵蓬松如棉花糖展开眼前，弯月微笑在缝隙间，月光柔和，清雅动人。<br>
		紫色天空如梦，星辉闪烁，默默倾听，轻轻地，微风拂面，悄悄地，生命在流动。
		`},7:{title:"《风平浪静》",author:"小雅",describe:`
		撑一条船，离开岸边一百米，风平浪静，彩霞慢慢淡下去。<br>
		撑一条船，离开岸边两百米，风平浪静，夜晚轻轻呼唤你。<br>
		撑一条船，离开岸边三百米，风平浪静，大鱼笑我傻兮兮。<br>
		撑一条船 离开岸边四百米，风平浪静，星儿闪闪笑眯眯。<br>
		撑一条船 离开岸边五百米，风平浪静，海龟向我挥手臂。
		`},8:{title:"《向日葵》",author:"小雅",describe:`
		阳光照耀，金黄的花盘。<br>
		宛如一盏明灯，指引前行。<br>
		向日葵，你是信仰，你是力量，你是光辉，你是坚毅，你是忠诚，你是爱慕，你是美丽。
		`},9:{title:"《花·虎·蝶》",author:"小雅",describe:`
		一段奇妙的相遇，是自由和勇气的结合，是一份神秘而又动人的韵味。<br>
		在这片色彩斑斓的花海之中，一只带着蝴蝶翅膀的老虎，骑着踏板车，<br>
		它像是一道闪电，划破了这片美好的天地。<br>
		翅膀轻轻地振动，仿佛随时可以飞离这片美好的天地，飞向更广阔的天空。
		`},10:{title:"《豚》",author:"小雅",describe:`
		所有的转折隐藏在密集的鸟群中，天空与海洋都无法察觉，怀着美梦却可以看见。<br>
		摸索颠倒的一瞬间，所有的怀念隐藏在相似的日子里，心里的蜘蛛模仿人类张灯结彩
		`}},lt={width:window.innerWidth,height:window.innerHeight},me=xn();var jt,qe,Ot,je,Ht,Oe,Xt,He,Gt,Xe;class os{constructor(t){R(this,jt);R(this,Ot);R(this,Ht);R(this,Xt);R(this,Gt);C(this,"loader",new hn);C(this,"textureLoader",new sn);C(this,"modelOffset",new B(0,-5,0));C(this,"collisionScene");C(this,"textureBoards",{});C(this,"galleryBoards",{});C(this,"scene");this.scene=t,V(this,Gt,Xe).call(this),V(this,Ot,je).call(this);const e=[V(this,jt,qe).call(this),V(this,Ht,Oe).call(this)];Promise.all(e).then(()=>{V(this,Xt,He).call(this)})}}jt=new WeakSet,qe=function(){const{loader:t,scene:e,modelOffset:n}=this;return new Promise((s,o)=>{t.load("model/scene_collision.glb",c=>{const a=c.scene;this.collisionScene=a,a.position.add(n),a.updateMatrixWorld(!0),a.traverse(l=>{(l.name==="home001"||l.name==="PointLight")&&(l.castShadow=!0),l.name.includes("PointLight")&&l instanceof on&&(l.intensity*=2e3),l.name==="home002"&&(l.castShadow=!0,l.receiveShadow=!0),l instanceof le&&/gallery.*_board/.test(l.name)&&(this.galleryBoards[l.name]=l)});const r=new ss(this.collisionScene);r.attributes=["position"];const u=r.generate();u.boundsTree=new gt(u,{lazyGeneration:!1}),me.value=new le(u),e.add(a),s(c)})})},Ot=new WeakSet,je=function(){const{loader:t,scene:e,modelOffset:n}=this;return new Promise(s=>{t.load("model/scene_desk_obj.glb",o=>{const c=o.scene;c.position.add(n),e.add(c),s(o)})})},Ht=new WeakSet,Oe=async function(){const{textureLoader:t,textureBoards:e}=this,n=[];function s(o){o.colorSpace=Fe;const c=o.image.width/o.image.height;let a=1,r=1;c>1?a=1/c:r=c,o.offset.set(.5-a/2,.5-r/2),o.repeat.set(a,r)}for(const[o,c]of is.entries()){const a=new Promise(r=>{t.load(c,u=>{s(u),e[o+1]=u,r(u)})});n.push(a)}return await Promise.all(n),e},Xt=new WeakSet,He=function(){const{textureBoards:t,galleryBoards:e}=this;for(const n in t){const s=e[`gallery${n}_board`],o=s.material;o.map=t[n],s.userData={name:s.name,title:ae[n].title,author:ae[n].author,describe:ae[n].describe,index:n,src:t[n].image.src,show_boards:!0},[4,5,6,7,9].includes(+n)&&(s.rotation.y=-Math.PI/2),+n==8&&(s.rotation.y=Math.PI)}},Gt=new WeakSet,Xe=function(){const t=new yn(new rn(100,100),{textureWidth:lt.width*window.devicePixelRatio,textureHeight:lt.height*window.devicePixelRatio,color:16777215});t.position.add(this.modelOffset),t.material instanceof cn&&(t.material.transparent=!0,t.material.fragmentShader=t.material.fragmentShader.replace("gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 )","gl_FragColor = vec4( blendOverlay( base.rgb, color ), 0.1 )")),t.rotation.x=-Math.PI/2,this.scene.add(t)};const rs=["w","W","ArrowUp"],cs=["s","S","ArrowDown"],as=["a","A","ArrowLeft"],ls=["d","D","ArrowRight"];var Yt,Zt,vt,he,Kt,Ge,$t,Ye;class fs{constructor(t,e,n){R(this,vt);R(this,Kt);R(this,$t);C(this,"moveState",{forward:!1,backward:!1,left:!1,right:!1,jump:!1});C(this,"character");C(this,"orbitController");C(this,"camera");C(this,"moveInfo",{tempVector:new B,upVector:new B(0,1,0),velocity:new B,speed:12,jumpHeight:20,gravity:-50});C(this,"capsule_info",{radius:1,segment:new E(new B,new B(0,-5,0))});C(this,"temp_box",new et);C(this,"temp_mat",new K);C(this,"temp_segment",new E);C(this,"temp_vector2",new B);R(this,Yt,t=>{V(this,vt,he).call(this,t,!0),console.log(this.moveState.jump),t.key===" "&&!this.moveState.jump&&(this.moveState.jump=!0,this.moveInfo.velocity.y=this.moveInfo.jumpHeight)});R(this,Zt,t=>{V(this,vt,he).call(this,t,!1)});C(this,"update",t=>{const{character:e,orbitController:n,camera:s}=this;V(this,Kt,Ge).call(this,t),me.value&&V(this,$t,Ye).call(this,t,me.value),s.position.sub(n.target),n.target.copy(e.position),s.position.add(e.position)});this.character=t,this.orbitController=e,this.camera=n,Ae("keydown",Qt(this,Yt)),Ae("keyup",Qt(this,Zt))}}Yt=new WeakMap,Zt=new WeakMap,vt=new WeakSet,he=function(t,e){if(rs.includes(t.key)){this.moveState.forward=e;return}if(cs.includes(t.key)){this.moveState.backward=e;return}if(as.includes(t.key)){this.moveState.left=e;return}if(ls.includes(t.key)){this.moveState.right=e;return}},Kt=new WeakSet,Ge=function(t){const{forward:e,backward:n,left:s,right:o,jump:c}=this.moveState;if(!(e||n||s||o||c))return;const{tempVector:a,velocity:r,speed:u,upVector:l,gravity:p}=this.moveInfo,{character:f,orbitController:m,camera:x}=this;a.set(0,0,0),e&&(a.z=-1),n&&(a.z=1),s&&(a.x=-1),o&&(a.x=1),c&&(r.y+=p*t,f.position.addScaledVector(r,t));const T=m.getAzimuthalAngle();a.applyAxisAngle(l,T),f.position.addScaledVector(a.normalize(),u*t),f.updateMatrixWorld()},$t=new WeakSet,Ye=function(t,e){var a,r;const n=this.capsule_info;this.temp_box.makeEmpty(),this.temp_mat.copy(e.matrixWorld).invert(),this.temp_segment.copy(n.segment),this.temp_segment.start.applyMatrix4(this.character.matrixWorld).applyMatrix4(this.temp_mat),this.temp_segment.end.applyMatrix4(this.character.matrixWorld).applyMatrix4(this.temp_mat),this.temp_box.expandByPoint(this.temp_segment.start),this.temp_box.expandByPoint(this.temp_segment.end),this.temp_box.min.addScalar(-n.radius),this.temp_box.max.addScalar(n.radius),(r=(a=e.geometry)==null?void 0:a.boundsTree)==null||r.shapecast({intersectsBounds:u=>u.intersectsBox(this.temp_box),intersectsTriangle:u=>{console.log(this.moveInfo.tempVector);const l=this.moveInfo.tempVector,p=this.temp_vector2,f=u.closestPointToSegment(this.temp_segment,l,p);if(f<n.radius){const m=n.radius-f,x=p.sub(l).normalize();this.temp_segment.start.addScaledVector(x,m),this.temp_segment.end.addScaledVector(x,m)}}});const s=this.moveInfo.tempVector;s.copy(this.temp_segment.start).applyMatrix4(e.matrixWorld);const o=this.temp_vector2;o.subVectors(s,this.character.position);const c=Math.max(0,o.length()-1e-5);o.normalize().multiplyScalar(c),this.character.position.add(o),o.y>Math.abs(t*this.moveInfo.velocity.y*.25)&&(this.moveState.jump=!1,this.moveInfo.velocity.set(0,0,0),this.character.position.y=0)};const ws=bn({__name:"Index",setup(i){const t=new an,e=new ln(50,lt.width/lt.height,1,9e3);e.position.set(0,0,3);const n=new fn({antialias:!0});n.setSize(lt.width,lt.height),n.setPixelRatio(window.devicePixelRatio),n.shadowMap.enabled=!0,n.outputColorSpace=Fe,n.toneMapping=un;const s=wn();An(()=>{s.value.appendChild(n.domElement)});const o=new $e(e,n.domElement);o.minDistance=1e-4,o.maxDistance=1e-4,new os(t);const c=new le(new Sn(.5,2.5,.5,10,1),new pn({color:255}));c.geometry.translate(0,-.25,0);const a=new fs(c,o,e);t.add(c);const r=new dn;return n.setAnimationLoop(()=>{n.render(t,e),o.update();const u=r.getDelta();a.update(u)}),gn(()=>{mn(t,n)}),(u,l)=>(Tn(),Pn("div",{ref_key:"containerRef",ref:s},null,512))}});export{ws as default};
